# 虚函数

在 C++ 中，**虚函数（Virtual Function）** 是一种通过基类指针或引用调用时可以实现多态行为的成员函数。虚函数允许在运行时根据实际对象的类型选择合适的函数版本，而不是在编译时决定调用哪个函数。虚函数是实现 C++ 中 **多态（Polymorphism）** 的关键机制。

### 1. 虚函数的定义

虚函数是由基类声明，并通过关键字 `virtual` 指定的成员函数。它允许派生类对该函数进行重写（override），并通过基类指针或引用调用时动态绑定到正确的派生类实现。

### 2. 虚函数的使用场景

虚函数的主要用途是在面向对象编程中实现多态行为。例如，当你有一个基类和多个派生类时，可以通过基类指针或引用来调用派生类中的重写函数，而不必关心具体的派生类类型。

### 3. 如何定义虚函数

虚函数在基类中定义时，需要在函数声明前加上 `virtual` 关键字。例如：

```cpp
#include <iostream>

// 基类
class Base {
public:
    // 定义虚函数
    virtual void display() {
        std::cout << "Base class display function." << std::endl;
    }

    // 虚析构函数（防止内存泄漏）
    virtual ~Base() {}
};

// 派生类
class Derived : public Base {
public:
    // 重写虚函数
    void display() override {
        std::cout << "Derived class display function." << std::endl;
    }
};

int main() {
    Base* ptr = new Derived();  // 基类指针指向派生类对象
    ptr->display();             // 调用派生类的 display 函数
    delete ptr;                 // 释放内存，调用虚析构函数
    return 0;
}
```

### 4. 关键点解释

- **动态绑定（Dynamic Binding）**：虚函数实现了动态绑定，即在运行时确定调用的是哪个版本的函数。以上例子中，`ptr->display()` 会调用 `Derived` 类的 `display` 函数，而不是 `Base` 类的函数。

- **函数重写（Override）**：派生类中可以重写基类的虚函数，使用相同的函数签名。C++11 及之后的标准允许使用 `override` 关键字显式声明函数是重写父类的虚函数，这样可以避免由于函数签名不匹配而导致的错误。

- **虚函数表（Vtable）**：虚函数的实现依赖于虚函数表（Vtable）。每个包含虚函数的类都有一个虚函数表，表中存储了指向该类的虚函数的指针。通过基类指针或引用调用虚函数时，程序会根据对象的实际类型查找虚函数表，从而找到正确的函数实现。

- **虚析构函数**：当一个基类有虚函数时，它的析构函数也应该是虚的。这是为了确保通过基类指针删除派生类对象时，派生类的析构函数能正确被调用，防止内存泄漏。

### 5. 常见误区

- **非虚函数不能实现多态**：如果没有将基类的函数声明为虚函数，即使派生类重写了该函数，通过基类指针或引用调用时，仍会调用基类版本，而非派生类版本。

- **虚函数影响性能**：由于虚函数使用了动态绑定，因此在调用虚函数时会有轻微的性能开销。但这种开销在大多数情况下是可以忽略的，换来的却是代码的灵活性和可扩展性。

- **不可以在构造函数或析构函数中调用虚函数**：在构造函数和析构函数中调用虚函数时，只会调用当前类的版本，而不会调用派生类的重写版本。这是因为在构造或析构期间，派生类的对象还未完成或已经开始销毁。

虚函数是 C++ 中实现多态性的重要特性，使得代码更加灵活和可扩展，是面向对象编程的核心机制之一。
