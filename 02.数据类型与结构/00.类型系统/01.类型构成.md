# 基本（内置）类型

不同于某些语言，C++ 中不存在派生所有其他类型的通用基类型。该语言包括许多基本类型（也称为“内置类型”）。这些类型分别包括数字类型（如 **`int`**、**`double`**、**`bool`**、**`long`**、以及 **`char`** ASCII 和 UNICODE 字符的 和 **`wchar_t`** 类型）。大多数基础类型（**`bool`**、**`double`**、**`wchar_t`** 和相关类型除外）都具有 **`unsigned`** 版本，这些版本修改了变量可存储的值的范围。例如，**`int`** 存储 32 位已签名整数，可表示介于 -2,147,483,648 和 2,147,483,647 之间的值。（ **`unsigned int`** 也存储为 32 位）可以存储从 0 到 4，294，967，295 的值。可能的值的总数在每种情况下都相同；仅范围不同。

编译器可识别这些内置类型，并且具有内置规则，用于控制可对其执行的操作，以及如何将它们转换为其他基本类型。下图显示了 Microsoft C++ 实现中内置类型的相对大小：

![类型系统大小](https://learn.microsoft.com/zh-cn/cpp/cpp/media/built-intypesizes.png?view=msvc-170)

下表列出了 Microsoft C++ 实现中最常使用的基本类型及其大小：

| 类型                | 大小     | 评论                                                                                                                                                            |
| :------------------ | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`int`**           | 4 个字节 | 整数值的默认选择。                                                                                                                                              |
| **`double`**        | 8 字节   | 浮点值的默认选择。                                                                                                                                              |
| **`bool`**          | 1 个字节 | 表示可为 true 或 false 的值。                                                                                                                                   |
| **`char`**          | 1 个字节 | 用于早期 C 样式字符串或 std:: 字符串对象中无需转换为 UNICODE 的 ASCII 字符。                                                                                    |
| **`wchar_t`**       | 2 个字节 | 表示可能以 UNICODE 格式进行编码的“宽”字符值（Windows 上为 UTF-16，其他操作系统上可能不同）。**`wchar_t`** 是在 类型为 的字符串中使用的字符类型 `std::wstring`。 |
| **`unsigned char`** | 1 个字节 | C++ 没有内置字节类型。使用 **`unsigned char`** 来表示字节值。                                                                                                   |
| **`unsigned int`**  | 4 个字节 | 位标志的默认选项。                                                                                                                                              |
| **`long long`**     | 8 字节   | 表示更大的整数值范围。                                                                                                                                          |

# void 类型

类型 void 是一种特殊类型;不能声明 类型的 void 变量，但可以声明类型为 的变量 void \* ， (指向 void) 的指针，这有时在分配原始 (非类型化) 内存时是必需的。但是，指向 void 的指针不是类型安全的，在现代 C++ 中不建议使用它们。在函数声明中， void 返回值表示函数不返回值;将其用作返回类型是 的常见且可接受的用法 void。虽然 C 语言要求在参数列表中声明 void 零个参数的函数（例如 fn(void)），但在新式 C++ 中不建议这种做法;应声明 fn()无参数函数。

# const 类型限定符

任何内置类型或用户定义类型都可以由 const 关键字 (keyword) 限定。此外，成员函数可受到 const 限定，甚至可重载 const。类型的值 const 在初始化后无法修改。

```c++
const double PI = 3.1415;
PI = .75; //Error. Cannot modify const variable.
```

限定 const 符在函数和变量声明中广泛使用，“常量正确性”是 C++ 中的一个重要概念;实质上，它意味着使用 const 来保证在编译时不会无意修改值。有关详细信息，请参阅 const。类型 const 不同于其非 const 版本;例如， const int 是不同于 int 的类型。如果发生必须从变量中移除常量性的这类少数情况，可使用 C++ const_cast 运算符。

# 字符串类型

严格来说，C++ 语言没有内置的字符串类型；**`char`** 和 **`wchar_t`** 存储单个字符 - 必须声明这些类型的数组来估计字符串，从而将一个终止 null 值（例如，ASCII `'\0'`）添加到最后一个有效字符数后的数组元素（也称为“C 样式字符串”）。C 样式字符串需要编写更多的代码或者需要使用外部字符串实用工具库函数。但是，在新式 C++ 中，我们具有标准库类型 `std::string`（用于 8 位 **`char`** 型字符串）或 `std::wstring`（用于 16 位 **`wchar_t`** 型字符串）。这些 C++ 标准库容器可以视为本机字符串类型，因为它们是包含在任何符合 C++ 生成环境中的标准库的一部分。`#include <string>`使用 指令使这些类型在程序中可用。(如果使用 MFC 或 ATL， `CString` 则 类也可用，但不属于 C++ 标准。) 新式 C++ 中不鼓励使用以 null 结尾的字符数组 (前面提到的 C 样式字符串) 。

# 用户定义类型

在定义 **`class`**、**`struct`**、**`union`** 或 **`enum`** 时，该构造会在代码的其余部分使用，如同它是一个基础类型一样。它具有内存的已知大小以及一些有关可以如何在程序生命期内将其用于编译时检查和运行时的规则。基本内置类型和用户定义的类型之间的主要区别如下：

- 编译器没有用户定义的类型的内置知识。它在编译过程中首次遇到此定义时就学习了此类型。
- 通过定义（通过重载）适当的运算符作为类成员或非成员函数，可以指定可对你的类型执行的操作以及你的类型转换为其他类型的方式。

# 指针类型

与 C 语言的最早版本一样，C++ 继续允许使用特殊声明符 **`*`** (星号) 声明指针类型的变量。指针类型在存储实际数据值的内存中存储位置地址。在现代 C++ 中，这些指针类型称为 _原始指针_，可通过特殊运算符在代码中访问它们： **`*`** (星号) 或 **`->`** (虚线大于（通常称为 _箭头_) ）。此内存访问操作称为 _取消引用_。使用哪个运算符取决于是要取消引用指向标量的指针，还是取消引用对象中成员的指针。

使用指针类型很长时间以来都是 C 和 C++ 程序开发的最具挑战性和最难以理解的方面之一。本部分概述了一些事实和做法，以帮助在需要时使用原始指针。但是，在现代 C++ 中，不再需要 (或推荐) 对对象所有权使用原始指针，因为 [智能指针](https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170) 的演变 (本节) 末尾对此进行了更多讨论。使用原始指针来观察对象仍然有用且安全。但是，如果必须将它们用于对象所有权，则应谨慎执行此操作，并仔细考虑如何创建和销毁它们拥有的对象。

首先，应该知道的是，原始指针变量声明仅分配足够的内存来存储地址：指针在取消引用时引用的内存位置。指针声明不会分配存储数据值所需的内存。(该内存也称为 _后备存储_。) 换言之，通过声明原始指针变量，你将创建内存地址变量，而不是实际数据变量。如果在确保指针变量包含后备存储的有效地址之前取消引用指针变量，则会导致未定义的行为 (通常是程序中) 致命错误。下面的示例演示了此种错误：与 C 语言的最早版本一样，C++ 继续允许使用特殊声明符 **`*`** (星号) 声明指针类型的变量。指针类型在存储实际数据值的内存中存储位置地址。在现代 C++ 中，这些指针类型称为 _原始指针_，可通过特殊运算符在代码中访问它们： **`*`** (星号) 或 **`->`** (虚线大于（通常称为 _箭头_) ）。此内存访问操作称为 _取消引用_。使用哪个运算符取决于是要取消引用指向标量的指针，还是取消引用对象中成员的指针。

使用指针类型很长时间以来都是 C 和 C++ 程序开发的最具挑战性和最难以理解的方面之一。本部分概述了一些事实和做法，以帮助在需要时使用原始指针。但是，在现代 C++ 中，不再需要 (或推荐) 对对象所有权使用原始指针，因为 [智能指针](https://learn.microsoft.com/zh-cn/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170) 的演变 (本节) 末尾对此进行了更多讨论。使用原始指针来观察对象仍然有用且安全。但是，如果必须将它们用于对象所有权，则应谨慎执行此操作，并仔细考虑如何创建和销毁它们拥有的对象。

首先，应该知道的是，原始指针变量声明仅分配足够的内存来存储地址：指针在取消引用时引用的内存位置。指针声明不会分配存储数据值所需的内存。(该内存也称为 _后备存储_。) 换言之，通过声明原始指针变量，你将创建内存地址变量，而不是实际数据变量。如果在确保指针变量包含后备存储的有效地址之前取消引用指针变量，则会导致未定义的行为 (通常是程序中) 致命错误。下面的示例演示了此种错误：

```cpp
int* pNumber;       // Declare a pointer-to-int variable.
*pNumber = 10;      // error. Although this may compile, it is
                    // a serious error. We are dereferencing an
                    // uninitialized pointer variable with no
                    // allocated memory to point to.
```

该示例取消引用指针类型，未分配用于存储实际整数数据的任何内存或向其分配有效内存地址。下面的代码更正这些错误：

```cpp
int number = 10;          // Declare and initialize a local integer
                              // variable for data backing store.
    int* pNumber = &number;   // Declare and initialize a local integer
                              // pointer variable to a valid memory
                              // address to that backing store.
...
    *pNumber = 41;            // Dereference and store a new value in
                              // the memory pointed to by
                              // pNumber, the integer variable called
                              // "number". Note "number" was changed, not
                              // "pNumber".
```

已纠正的代码示例使用本地堆栈内存创建 pNumber 指向的后备存储。我们使用基本类型，以求简单。在实践中，指针的后备存储通常是用户定义的类型，这些类型在称为堆 (或自由存储) 的内存区域中动态分配，方法是使用 new C 样式编程中的关键字 (keyword) 表达式 (，) 使用较旧的 malloc() C 运行时库函数。分配后，这些变量通常称为 对象，尤其是在它们基于类定义的情况下。使用 new 分配的内存必须由相应的 delete 语句删除（如果使用 malloc() 函数进行关联，则使用 C 运行时函数 free() 执行删除操作）。

但是，很容易忘记删除动态分配的对象，尤其是在复杂的代码中，这会导致称为 内存泄漏的资源 bug。因此，新式 C++ 中不建议使用原始指针。将原始指针包装在智能指针中几乎总是更好，智能 指针会在调用其析构函数时自动释放内存。(也就是说，当代码超出智能指针的范围时。) 通过使用智能指针，几乎可以消除 C++ 程序中的一整类 bug。在下面的示例中，假定 MyClass 是具有公共方法 DoSomeWork(); 的用户定义的类型

```cpp
void someFunction() {
    unique_ptr<MyClass> pMc(new MyClass);
    pMc->DoSomeWork();
}
  // No memory leak. Out-of-scope automatically calls the destructor
  // for the unique_ptr, freeing the resource.
```
