# 构建项目

本章的主要内容如下：

- 使用函数和宏重用代码
- 将 CMake 源代码分成模块
- 编写函数来测试和设置编译器标志
- 用指定参数定义函数或宏
- 重新定义函数和宏
- 使用废弃函数、宏和变量
- add_subdirectory 的限定范围
- 使用 target_sources 避免全局变量
- 组织 Fortran 项目

前几章中，我们已经使用了一些 CMake 构建块来配置和构建的项目。本章中，我们将讨论如何组合这些构建块，并引入抽象，并最小化代码重复、全局变量、全局状态和显式排序，以免 CMakeLists.txt 文件过于庞大。目标是为模块化 CMake 代码结构和限制变量范围提供模式。我们将讨论一些策略，也将帮助我们控制中大型代码项目的 CMake 代码复杂性。

# 7.1 使用函数和宏重用代码

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-01 中找到，其中包含一个 C++例子。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

任何编程语言中，函数允许我们抽象(隐藏)细节并避免代码重复，CMake 也不例外。本示例中，我们将以宏和函数为例进行讨论，并介绍一个宏，以便方便地定义测试和设置测试的顺序。我们的目标是定义一个宏，能够替换`add_test`和`set_tests_properties`，用于定义每组和设置每个测试的预期开销(第 4 章，第 8 节)。

## 准备工作

我们将基于第 4 章第 2 节中的例子。`main.cpp`、`sum_integers.cpp`和`sum_integers.hpp`文件不变，用来计算命令行参数提供的整数队列的和。单元测试(`test.cpp`)的源代码也没有改变。我们还需要 Catch 2 头文件，`catch.hpp`。与第 4 章相反，我们将把源文件放到子目录中，并形成以下文件树(稍后我们将讨论 CMake 代码):

```
.
├── CMakeLists.txt
├── src
│     ├── CMakeLists.txt
│     ├── main.cpp
│     ├── sum_integers.cpp
│     └── sum_integers.hpp
└── tests
      ├── catch.hpp
      ├── CMakeLists.txt
      └── test.cpp
```

## 具体实施

1. 定义了 CMake 最低版本、项目名称和支持的语言，并要求支持 C++11 标准:

   ```
   cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
   project(recipe-01 LANGUAGES CXX)
   set(CMAKE_CXX_STANDARD 11)
   set(CMAKE_CXX_EXTENSIONS OFF)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   ```

2. 根据 GNU 标准定义`binary`和`library`路径:

   ```
   include(GNUInstallDirs)

   set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY
   	${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_LIBRARY_OUTPUT_DIRECTORY
   	${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_RUNTIME_OUTPUT_DIRECTORY
   	${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})
   ```

3. 最后，使用`add_subdirectory`调用`src/CMakeLists.txt`和`tests/CMakeLists.txt`:

   ```
   add_subdirectory(src)
   enable_testing()
   add_subdirectory(tests)
   ```

4. `src/CMakeLists.txt`定义了源码目标:

   ```
   set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)
   add_library(sum_integers sum_integers.cpp)
   add_executable(sum_up main.cpp)
   target_link_libraries(sum_up sum_integers)
   ```

5. `tests/CMakeLists.txt`中，构建并链接`cpp_test`可执行文件:

   ```
   add_executable(cpp_test test.cpp)
   target_link_libraries(cpp_test sum_integers)
   ```

6. 定义一个新宏`add_catch_test`:

   ```
   macro(add_catch_test _name _cost)
     math(EXPR num_macro_calls "${num_macro_calls} + 1")
     message(STATUS "add_catch_test called with ${ARGC} arguments: ${ARGV}")

     set(_argn "${ARGN}")
     if(_argn)
     	message(STATUS "oops - macro received argument(s) we did not expect: ${ARGN}")
     endif()

     add_test(
       NAME
         ${_name}
       COMMAND
         $<TARGET_FILE:cpp_test>
       [${_name}] --success --out
       ${PROJECT_BINARY_DIR}/tests/${_name}.log --durations yes
       WORKING_DIRECTORY
         ${CMAKE_CURRENT_BINARY_DIR}
       )

     set_tests_properties(
       ${_name}
       PROPERTIES
       	COST ${_cost}
       )
   endmacro()
   ```

7. 最后，使用`add_catch_test`定义了两个测试。此外，还设置和打印了变量的值:

   ```
   set(num_macro_calls 0)
   add_catch_test(short 1.5)
   add_catch_test(long 2.5 extra_argument)
   message(STATUS "in total there were ${num_macro_calls} calls to add_catch_test")
   ```

8. 现在，进行测试。配置项目(输出行如下所示):

   ```
   $ mkdir -p build
   $ cd build
   $ cmake ..

   -- ...
   -- add_catch_test called with 2 arguments: short;1.5
   -- add_catch_test called with 3 arguments: long;2.5;extra_argument
   -- oops - macro received argument(s) we did not expect: extra_argument
   -- in total there were 2 calls to add_catch_test
   -- ...
   ```

9. 最后，构建并运行测试:

   ```
   $ cmake --build .
   $ ctest
   ```

10. 长时间的测试会先开始:

    ```
    Start 2: long
    1/2 Test #2: long ............................. Passed 0.00 sec
    Start 1: short
    2/2 Test #1: short ............................ Passed 0.00 sec

    100% tests passed, 0 tests failed out of 2
    ```

## 工作原理

这个配置中的新添加了`add_catch_test`宏。这个宏需要两个参数`_name`和`_cost`，可以在宏中使用这些参数来调用`add_test`和`set_tests_properties`。参数前面的下划线，是为了向读者表明这些参数只能在宏中访问。另外，宏自动填充了`${ARGC}`(参数数量)和`${ARGV}`(参数列表)，我们可以在输出中验证了这一点:

```
-- add_catch_test called with 2 arguments: short;1.5
-- add_catch_test called with 3 arguments: long;2.5;extra_argument
```

宏还定义了`${ARGN}`，用于保存最后一个参数之后的参数列表。此外，我们还可以使用`${ARGV0}`、`${ARGV1}`等来处理参数。我们演示一下，如何捕捉到调用中的额外参数(`extra_argument`):

```
add_catch_test(long 2.5 extra_argument)
```

我们使用了以下方法:

```
set(_argn "${ARGN}")
if(_argn)
	message(STATUS "oops - macro received argument(s) we did not expect: ${ARGN}")
endif()
```

这个`if`语句中，我们引入一个新变量，但不能直接查询`ARGN`，因为它不是通常意义上的 CMake 变量。使用这个宏，我们可以通过它们的名称和命令来定义测试，还可以指示预期的开销，这会让耗时长的测试在耗时短测试之前启动，这要归功于`COST`属性。

我们可以用一个函数来实现它，而不是使用相同语法的宏:

```
function(add_catch_test _name _cost)
	...
endfunction()
```

宏和函数之间的区别在于它们的变量范围。宏在调用者的范围内执行，而函数有自己的变量范围。换句话说，如果我们使用宏，需要设置或修改对调用者可用的变量。如果不去设置或修改输出变量，最好使用函数。我们注意到，可以在函数中修改父作用域变量，但这必须使用`PARENT_SCOPE`显式表示:

```
set(variable_visible_outside "some value" PARENT_SCOPE)
```

为了演示作用域，我们在定义宏之后编写了以下调用:

```
set(num_macro_calls 0)
add_catch_test(short 1.5)
add_catch_test(long 2.5 extra_argument)
message(STATUS "in total there were ${num_macro_calls} calls to add_catch_test")
```

在宏内部，将`num_macro_calls`加 1:

```
math(EXPR num_macro_calls "${num_macro_calls} + 1")
```

这时产生的输出:

```
-- in total there were 2 calls to add_catch_test
```

如果我们将宏更改为函数，测试仍然可以工作，但是`num_macro_calls`在父范围内的所有调用中始终为 0。将 CMake 宏想象成类似函数是很有用的，这些函数被直接替换到它们被调用的地方(在 C 语言中内联)。将 CMake 函数想象成黑盒函数很有必要。黑盒中，除非显式地将其定义为`PARENT_SCOPE`，否则不会返回任何内容。CMake 中的函数没有返回值。

## 更多信息

可以在宏中嵌套函数调用，也可以在函数中嵌套宏调用，但是这就需要仔细考虑变量的作用范围。如果功能可以使用函数实现，那么这可能比宏更好，因为它对父范围状态提供了更多的默认控制。

我们还应该提到在`src/cmakelist .txt`中使用`CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE`:

```
set(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)
```

这个命令会将当前目录，添加到`CMakeLists.txt`中定义的所有目标的`interface_include_directory`属性中。换句话说，我们不需要使用`target_include_directory`来添加`cpp_test`所需头文件的位置。

# 7.2 将 CMake 源代码分成模块

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-02 中找到。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

项目通常从单个`CMakeLists.txt`文件开始，随着时间的推移，这个文件会逐渐增长。本示例中，我们将演示一种将`CMakeLists.txt`分割成更小单元的机制。将`CMakeLists.txt`拆分为模块有几个动机，这些模块可以包含在主`CMakeLists.txt`或其他模块中:

- 主`CMakeLists.txt`更易于阅读。
- CMake 模块可以在其他项目中重用。
- 与函数相结合，模块可以帮助我们限制变量的作用范围。

本示例中，我们将演示如何定义和包含一个宏，该宏允许我们获得 CMake 的彩色输出(用于重要的状态消息或警告)。

## 准备工作

本例中，我们将使用两个文件，主`CMakeLists.txt`和`cmake/colors.cmake`:

```
.
├── cmake
│     └── colors.cmake
└── CMakeLists.txt
```

`cmake/colors.cmake`文件包含彩色输出的定义:

```
# colorize CMake output
# code adapted from stackoverflow: http://stackoverflow.com/a/19578320
# from post authored by https://stackoverflow.com/users/2556117/fraser
macro(define_colors)
  if(WIN32)
    # has no effect on WIN32
    set(ColourReset "")
    set(ColourBold "")
    set(Red "")
    set(Green "")
    set(Yellow "")
    set(Blue "")
    set(Magenta "")
    set(Cyan "")
    set(White "")
    set(BoldRed "")
    set(BoldGreen "")
    set(BoldYellow "")
    set(BoldBlue "")
    set(BoldMagenta "")
    set(BoldCyan "")
    set(BoldWhite "")
  else()
    string(ASCII 27 Esc)
    set(ColourReset "${Esc}[m")
    set(ColourBold "${Esc}[1m")
    set(Red "${Esc}[31m")
    set(Green "${Esc}[32m")
    set(Yellow "${Esc}[33m")
    set(Blue "${Esc}[34m")
    set(Magenta "${Esc}[35m")
    set(Cyan "${Esc}[36m")
    set(White "${Esc}[37m")
    set(BoldRed "${Esc}[1;31m")
    set(BoldGreen "${Esc}[1;32m")
    set(BoldYellow "${Esc}[1;33m")
    set(BoldBlue "${Esc}[1;34m")
    set(BoldMagenta "${Esc}[1;35m")
    set(BoldCyan "${Esc}[1;36m")
    set(BoldWhite "${Esc}[1;37m")
  endif()
endmacro()
```

## 具体实施

来看下我们如何使用颜色定义，来生成彩色状态消息:

1. 从一个熟悉的头部开始:

   ```
   cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
   project(recipe-02 LANGUAGES NONE)
   ```

2. 然后，将`cmake`子目录添加到 CMake 模块搜索的路径列表中:

   ```
   list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
   ```

3. 包括`colors.cmake`模块，调用其中定义的宏:

   ```
   include(colors)
   define_colors()
   ```

4. 最后，打印了不同颜色的信息:

   ```
   message(STATUS "This is a normal message")
   message(STATUS "${Red}This is a red${ColourReset}")
   message(STATUS "${BoldRed}This is a bold red${ColourReset}")
   message(STATUS "${Green}This is a green${ColourReset}")
   message(STATUS "${BoldMagenta}This is bold${ColourReset}")
   ```

5. 测试一下(如果使用 macOS 或 Linux，以下的输出应该出现屏幕上):[![img](https://github.com/xiaoweiChen/CMake-Cookbook/raw/master/images/chapter7/7-2-1.png)](https://github.com/xiaoweiChen/CMake-Cookbook/blob/master/images/chapter7/7-2-1.png)

## 工作原理

这个例子中，不需要编译代码，也不需要语言支持，我们已经用`LANGUAGES NONE`明确了这一点：

```
project(recipe-02 LANGUAGES NONE)
```

我们定义了`define_colors`宏，并将其放在`cmake/colors.cmake`。因为还是希望使用调用宏中定义的变量，来更改消息中的颜色，所以我们选择使用宏而不是函数。我们使用以下行包括宏和调用`define_colors`:

```
include(colors)
define_colors()
```

我们还需要告诉 CMake 去哪里查找宏:

```
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
```

`include(colors)`命令指示 CMake 搜索`${CMAKE_MODULE_PATH}`，查找名称为`colors.cmake`的模块。

例子中，我们没有按以下的方式进行：

```
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
include(colors)
```

而是使用一个显式包含的方式:

```
include(cmake/colors.cmake)
```

## 更多信息

推荐的做法是在模块中定义宏或函数，然后调用宏或函数。将包含模块用作函数调用不是很好的方式。除了定义函数和宏以及查找程序、库和路径之外，包含模块不应该做更多的事情。实际的`include`命令不应该定义或修改变量，其原因是重复的`include`(可能是偶然的)不应该引入任何不想要的副作用。在第 5 节中，我们将创建一个防止多次包含的保护机制。

# 7.3 编写函数来测试和设置编译器标志

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-03 中找到，其中包含一个 C/C++示例。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

前两个示例中，我们使用了宏。本示例中，将使用一个函数来抽象细节并避免代码重复。我们将实现一个接受编译器标志列表的函数。该函数将尝试用这些标志逐个编译测试代码，并返回编译器理解的第一个标志。这样，我们将了解几个新特性：函数、列表操作、字符串操作，以及检查编译器是否支持相应的标志。

## 准备工作

按照上一个示例的推荐，我们将在(`set_compiler_flag.cmake`)模块中定义函数，然后调用函数。该模块包含以下代码，我们将在后面详细讨论:

```
include(CheckCCompilerFlag)
include(CheckCXXCompilerFlag)
include(CheckFortranCompilerFlag)
function(set_compiler_flag _result _lang)
  # build a list of flags from the arguments
  set(_list_of_flags)
  # also figure out whether the function
  # is required to find a flag
  set(_flag_is_required FALSE)
  foreach(_arg IN ITEMS ${ARGN})
  	string(TOUPPER "${_arg}" _arg_uppercase)
  	if(_arg_uppercase STREQUAL "REQUIRED")
  		set(_flag_is_required TRUE)
  	else()
  		list(APPEND _list_of_flags "${_arg}")
  	endif()
  endforeach()

  set(_flag_found FALSE)
  # loop over all flags, try to find the first which works
  foreach(flag IN ITEMS ${_list_of_flags})
  	unset(_flag_works CACHE)
  	if(_lang STREQUAL "C")
  		check_c_compiler_flag("${flag}" _flag_works)
  	elseif(_lang STREQUAL "CXX")
  		check_cxx_compiler_flag("${flag}" _flag_works)
  	elseif(_lang STREQUAL "Fortran")
  		check_Fortran_compiler_flag("${flag}" _flag_works)
  	else()
  		message(FATAL_ERROR "Unknown language in set_compiler_flag: ${_lang}")
 	 	endif()

    # if the flag works, use it, and exit
    # otherwise try next flag
    if(_flag_works)
      set(${_result} "${flag}" PARENT_SCOPE)
      set(_flag_found TRUE)
      break()
    endif()
  endforeach()

  # raise an error if no flag was found
  if(_flag_is_required AND NOT _flag_found)
  	message(FATAL_ERROR "None of the required flags were supported")
  endif()
endfunction()
```

## 具体实施

展示如何在 CMakeLists.txt 中使用`set_compiler_flag`函数:

1. 定义最低 CMake 版本、项目名称和支持的语言(本例中是 C 和 C++):

   ```
   cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
   project(recipe-03 LANGUAGES C CXX)
   ```

2. 显示包含`set_compiler_flag.cmake`:

   ```
   include(set_compiler_flag.cmake)
   ```

3. 测试 C 标志列表:

   ```
   set_compiler_flag(
     working_compile_flag C REQUIRED
     "-foo" # this should fail
     "-wrong" # this should fail
     "-wrong" # this should fail
     "-Wall" # this should work with GNU
     "-warn all" # this should work with Intel
     "-Minform=inform" # this should work with PGI
     "-nope" # this should fail
     )

   message(STATUS "working C compile flag: ${working_compile_flag}")
   ```

4. 测试 C++标志列表:

   ```
   set_compiler_flag(
     working_compile_flag CXX REQUIRED
     "-foo" # this should fail
     "-g" # this should work with GNU, Intel, PGI
     "/RTCcsu" # this should work with MSVC
     )

   message(STATUS "working CXX compile flag: ${working_compile_flag}")
   ```

5. 现在，我们可以配置项目并验证输出。只显示相关的输出，相应的输出可能会因编译器的不同而有所不同:

   ```
   $ mkdir -p build
   $ cd build
   $ cmake ..

   -- ...
   -- Performing Test _flag_works
   -- Performing Test _flag_works - Failed
   -- Performing Test _flag_works
   -- Performing Test _flag_works - Failed
   -- Performing Test _flag_works
   -- Performing Test _flag_works - Failed
   -- Performing Test _flag_works
   -- Performing Test _flag_works - Success
   -- working C compile flag: -Wall
   -- Performing Test _flag_works
   -- Performing Test _flag_works - Failed
   -- Performing Test _flag_works
   -- Performing Test _flag_works - Success
   -- working CXX compile flag: -g
   -- ...
   ```

## 工作原理

这里使用的模式是:

1. 定义一个函数或宏，并将其放入模块中
2. 包含模块
3. 调用函数或宏

从输出中，可以看到代码检查列表中的每个标志。一旦检查成功，它就打印成功的编译标志。看看`set_compiler_flag.cmake`模块的内部，这个模块又包含三个模块:

```
include(CheckCCompilerFlag)
include(CheckCXXCompilerFlag)
include(CheckFortranCompilerFlag)
```

这都是标准的 CMake 模块，CMake 将在`${CMAKE_MODULE_PATH}`中找到它们。这些模块分别提供`check_c_compiler_flag`、`check_cxx_compiler_flag`和`check_fortran_compiler_flag`宏。然后定义函数:

```
function(set_compiler_flag _result _lang)
	...
endfunction()
```

`set_compiler_flag`函数需要两个参数，`_result`(保存成功编译标志或为空字符串)和`_lang`(指定语言:C、C++或 Fortran)。

我们也能这样调用函数:

```
set_compiler_flag(working_compile_flag C REQUIRED "-Wall" "-warn all")
```

这里有五个调用参数，但是函数头只需要两个参数。这意味着`REQUIRED`、`-Wall`和`-warn all`将放在`${ARGN}`中。从`${ARGN}`开始，我们首先使用`foreach`构建一个标志列表。同时，从标志列表中过滤出`REQUIRED`，并使用它来设置`_flag_is_required`:

```
# build a list of flags from the arguments
set(_list_of_flags)
# also figure out whether the function
# is required to find a flag
set(_flag_is_required FALSE)
foreach(_arg IN ITEMS ${ARGN})
  string(TOUPPER "${_arg}" _arg_uppercase)
  if(_arg_uppercase STREQUAL "REQUIRED")
  	set(_flag_is_required TRUE)
  else()
  	list(APPEND _list_of_flags "${_arg}")
  endif()
endforeach()
```

现在，我们将循环`${_list_of_flags}`，尝试每个标志，如果`_flag_works`被设置为`TRUE`，我们将`_flag_found`设置为`TRUE`，并中止进一步的搜索:

```
set(_flag_found FALSE)
# loop over all flags, try to find the first which works
foreach(flag IN ITEMS ${_list_of_flags})

  unset(_flag_works CACHE)
  if(_lang STREQUAL "C")
  	check_c_compiler_flag("${flag}" _flag_works)
  elseif(_lang STREQUAL "CXX")
  	check_cxx_compiler_flag("${flag}" _flag_works)
  elseif(_lang STREQUAL "Fortran")
  	check_Fortran_compiler_flag("${flag}" _flag_works)
  else()
  	message(FATAL_ERROR "Unknown language in set_compiler_flag: ${_lang}")
  endif()

  # if the flag works, use it, and exit
  # otherwise try next flag
  if(_flag_works)
  	set(${_result} "${flag}" PARENT_SCOPE)
  	set(_flag_found TRUE)
  	break()
  endif()
endforeach()
```

`unset(_flag_works CACHE)`确保`check_*_compiler_flag`的结果，不会在使用`_flag_works result`变量时，使用的是缓存结果。

如果找到了标志，并且`_flag_works`设置为`TRUE`，我们就将`_result`映射到的变量:

```
set(${_result} "${flag}" PARENT_SCOPE)
```

这需要使用`PARENT_SCOPE`来完成，因为我们正在修改一个变量，希望打印并在函数体外部使用该变量。请注意，如何使用`${_result}`语法解引用，从父范围传递的变量`_result`的值。不管函数的名称是什么，这对于确保工作标志被设置非常有必要。如果没有找到任何标志，并且该标志设置了`REQUIRED`，那我们将使用一条错误消息停止配置:

```
# raise an error if no flag was found
if(_flag_is_required AND NOT _flag_found)
	message(FATAL_ERROR "None of the required flags were supported")
endif()
```

## 更多信息

我们也可以使用宏来完成这个任务，而使用函数可以对范围有更多的控制。我们知道函数只能可以修改结果变量。

另外，需要在编译和链接时设置一些标志，方法是为`check_<lang>_compiler_flag`函数设置`CMAKE_REQUIRED_FLAGS`。如第 5 章，第 7 节中讨论的那样，Sanitizer 就是这种情况。

# 7.4 用指定参数定义函数或宏

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-04 中找到，其中包含一个 C++示例。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

前面的示例中，我们研究了函数和宏，并使用了位置参数。这个示例中，我们将定义一个带有命名参数的函数。我们将复用第 1 节中的示例，使用函数和宏重用代码，而不是使用以下代码定义测试：`add_catch_test(short 1.5)`。

我们将这样调用函数:

```
add_catch_test(
	NAME
  	short
  LABELS
  	short
  	cpp_test
  COST
  	1.5
  )
```

## 准备工作

我们使用第 1 节中的示例，使用函数和宏重用代码，并保持 C++源代码不变，文件树保持不变：

```
.
├── cmake
│     └── testing.cmake
├── CMakeLists.txt
├── src
│     ├── CMakeLists.txt
│     ├── main.cpp
│     ├── sum_integers.cpp
│     └── sum_integers.hpp
└── tests
    ├── catch.hpp
    ├── CMakeLists.txt
    └── test.cpp
```

## 具体实施

我们对 CMake 代码进行一些修改，如下所示:

1. `CMakeLists.txt`顶部中只增加了一行，因为我们将包括位于`cmake`下面的模块:

   ```
   list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
   ```

2. 保持`src/CMakeLists.txt`。

3. `tests/CMakeLists.txt`中，将`add_catch_test`函数定义移动到`cmake/testing.cmake`，并且定义两个测试:

   ```
   add_executable(cpp_test test.cpp)
   target_link_libraries(cpp_test sum_integers)

   include(testing)

   add_catch_test(
     NAME
     	short
     LABELS
     	short
     	cpp_test
     COST
     	1.5
     )

   add_catch_test(
     NAME
     	long
     LABELS
     	long
     	cpp_test
     COST
     	2.5
     )
   ```

4. `add_catch_test`在`cmake/testing.cmake`中定义:

   ```
   function(add_catch_test)
     set(options)
     set(oneValueArgs NAME COST)
     set(multiValueArgs LABELS DEPENDS REFERENCE_FILES)
     cmake_parse_arguments(add_catch_test
       "${options}"
       "${oneValueArgs}"
       "${multiValueArgs}"
       ${ARGN}
       )
     message(STATUS "defining a test ...")
     message(STATUS " NAME: ${add_catch_test_NAME}")
     message(STATUS " LABELS: ${add_catch_test_LABELS}")
     message(STATUS " COST: ${add_catch_test_COST}")
     message(STATUS " REFERENCE_FILES: ${add_catch_test_REFERENCE_FILES}")

     add_test(
       NAME
       	${add_catch_test_NAME}
       COMMAND
       	$<TARGET_FILE:cpp_test>
       [${add_catch_test_NAME}] --success --out
       	${PROJECT_BINARY_DIR}/tests/${add_catch_test_NAME}.log --durations yes
       WORKING_DIRECTORY
       	${CMAKE_CURRENT_BINARY_DIR}
       )

     set_tests_properties(${add_catch_test_NAME}
       PROPERTIES
       	LABELS "${add_catch_test_LABELS}"
       )

     if(add_catch_test_COST)
       set_tests_properties(${add_catch_test_NAME}
       PROPERTIES
       	COST ${add_catch_test_COST}
       )
     endif()

     if(add_catch_test_DEPENDS)
       set_tests_properties(${add_catch_test_NAME}
         PROPERTIES
         	DEPENDS ${add_catch_test_DEPENDS}
         )
     endif()

     if(add_catch_test_REFERENCE_FILES)
       file(
         COPY
         	${add_catch_test_REFERENCE_FILES}
         DESTINATION
         	${CMAKE_CURRENT_BINARY_DIR}
         )
     endif()
   endfunction()
   ```

5. 测试输出:

   ```
   $ mkdir -p build
   $ cd build
   $ cmake ..

   -- ...
   -- defining a test ...
   -- NAME: short
   -- LABELS: short;cpp_test
   -- COST: 1.5
   -- REFERENCE_FILES:
   -- defining a test ...
   -- NAME: long
   -- LABELS: long;cpp_test
   -- COST: 2.5
   -- REFERENCE_FILES:
   -- ...
   ```

6. 最后，编译并测试：

   ```
   $ cmake --build .
   $ ctest
   ```

## 工作原理

示例的特点是其命名参数，因此我们可以将重点放在`cmake/testing.cmake`模块上。CMake 提供`cmake_parse_arguments`命令，我们使用函数名(`add_catch_test`)选项(我们的例子中是`none`)、单值参数(`NAME`和`COST`)和多值参数(`LABELS`、`DEPENDS`和`REFERENCE_FILES`)调用该命令:

```
function(add_catch_test)
  set(options)
  set(oneValueArgs NAME COST)
  set(multiValueArgs LABELS DEPENDS REFERENCE_FILES)
  cmake_parse_arguments(add_catch_test
    "${options}"
    "${oneValueArgs}"
    "${multiValueArgs}"
    ${ARGN}
    )
...
endfunction()
```

`cmake_parse_arguments`命令解析选项和参数，并在例子中定义如下:

- add_catch_test_NAME
- add_catch_test_COST
- add_catch_test_LABELS
- add_catch_test_DEPENDS
- add_catch_test_REFERENCE_FILES

可以查询，并在函数中使用这些变量。这种方法使我们有机会用更健壮的接口和更具有可读的函数/宏调用，来实现函数和宏。

## 更多信息

选项关键字(本例中我们没有使用)由`cmake_parse_arguments`定义为`TRUE`或`FALSE`。`add_catch_test`函数，还提供`test`命令作为一个命名参数，为了更简洁的演示，我们省略了这个参数。

**TIPS**:_`cmake_parse_arguments`命令在 cmake 3.5 的版本前中的`CMakeParseArguments.cmake`定义。因此，可以在`CMake/test.cmake`顶部的使用`include(CMakeParseArguments)`命令使此示例能与 CMake 早期版本一起工作。_

# 7.5 重新定义函数和宏

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-05 中找到。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

我们已经提到模块包含不应该用作函数调用，因为模块可能被包含多次。本示例中，我们将编写我们自己的“包含保护”机制，如果多次包含一个模块，将触发警告。内置的`include_guard`命令从 3.10 版开始可以使用，对于 C/C++头文件，它的行为就像`#pragma`一样。对于当前版本的 CMake，我们将演示如何重新定义函数和宏，并且展示如何检查 CMake 版本，对于低于 3.10 的版本，我们将使用定制的“包含保护”机制。

## 准备工作

这个例子中，我们将使用三个文件:

```
.
├── cmake
│     ├── custom.cmake
│     └── include_guard.cmake
└── CMakeLists.txt
```

`custom.cmake`模块包含以下代码:

```
include_guard(GLOBAL)
message(STATUS "custom.cmake is included and processed")
```

我们稍后会对`cmake/include_guard.cmake`进行讨论。

## 具体实施

我们对三个 CMake 文件的逐步分解:

1. 示例中，我们不会编译任何代码，因此我们的语言要求是`NONE`:

   ```
   cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
   project(recipe-05 LANGUAGES NONE)
   ```

2. 定义一个`include_guard`宏，将其放在一个单独的模块中:

   ```
   # (re)defines include_guard
   include(cmake/include_guard.cmake)
   ```

3. `cmake/include_guard.cmake`文件包含以下内容(稍后将详细讨论):

   ```
   macro(include_guard)
     if (CMAKE_VERSION VERSION_LESS "3.10")
       # for CMake below 3.10 we define our
       # own include_guard(GLOBAL)
       message(STATUS "calling our custom include_guard")

       # if this macro is called the first time
       # we start with an empty list
       if(NOT DEFINED included_modules)
         set(included_modules)
       endif()

       if ("${CMAKE_CURRENT_LIST_FILE}" IN_LIST included_modules)
         message(WARNING "module ${CMAKE_CURRENT_LIST_FILE} processed more than once")
       endif()

       list(APPEND included_modules ${CMAKE_CURRENT_LIST_FILE})
       else()
       # for CMake 3.10 or higher we augment
       # the built-in include_guard
       message(STATUS "calling the built-in include_guard")

       _include_guard(${ARGV})
     endif()
   endmacro()
   ```

4. 主 CMakeLists.txt 中，我们模拟了两次包含自定义模块的情况:

   ```
   include(cmake/custom.cmake)
   include(cmake/custom.cmake)
   ```

5. 最后，使用以下命令进行配置:

   ```
   $ mkdir -p build
   $ cd build
   $ cmake ..
   ```

6. 使用 CMake 3.10 及更高版本的结果如下:

   ```
   -- calling the built-in include_guard
   -- custom.cmake is included and processed
   -- calling the built-in include_guard
   ```

7. 使用 CMake 得到 3.10 以下的结果如下:

   ```
   - calling our custom include_guard
   -- custom.cmake is included and processed
   -- calling our custom include_guard
   CMake Warning at cmake/include_guard.cmake:7 (message):
   module
   /home/user/example/cmake/custom.cmake
   processed more than once
   Call Stack (most recent call first):
   cmake/custom.cmake:1 (include_guard)
   CMakeLists.txt:12 (include)
   ```

## 工作原理

`include_guard`宏包含两个分支，一个用于 CMake 低于 3.10，另一个用于 CMake 高于 3.10:

```
macro(include_guard)
  if (CMAKE_VERSION VERSION_LESS "3.10")
  	# ...
  else()
  	# ...
  endif()
endmacro()
```

如果 CMake 版本低于 3.10，进入第一个分支，并且内置的`include_guard`不可用，所以我们自定义了一个:

```
message(STATUS "calling our custom include_guard")

# if this macro is called the first time
# we start with an empty list
if(NOT DEFINED included_modules)
	set(included_modules)
endif()

if ("${CMAKE_CURRENT_LIST_FILE}" IN_LIST included_modules)
	message(WARNING "module ${CMAKE_CURRENT_LIST_FILE} processed more than once")
endif()

list(APPEND included_modules ${CMAKE_CURRENT_LIST_FILE})
```

如果第一次调用宏，则`included_modules`变量没有定义，因此我们将其设置为空列表。然后检查`${CMAKE_CURRENT_LIST_FILE}`是否是`included_modules`列表中的元素。如果是，则会发出警告；如果没有，我们将`${CMAKE_CURRENT_LIST_FILE}`追加到这个列表。CMake 输出中，我们可以验证自定义模块的第二个包含确实会导致警告。

CMake 3.10 及更高版本的情况有所不同；在这种情况下，存在一个内置的`include_guard`，我们用自己的宏接收到参数并调用它:

```
macro(include_guard)
  if (CMAKE_VERSION VERSION_LESS "3.10")
  	# ...
  else()
  	message(STATUS "calling the built-in include_guard")

  	_include_guard(${ARGV})
  endif()
endmacro()
```

这里，`_include_guard(${ARGV})`指向内置的`include_guard`。本例中，使用自定义消息(“调用内置的`include_guard`”)进行了扩展。这种模式为我们提供了一种机制，来重新定义自己的或内置的函数和宏，这对于调试或记录日志来说非常有用。

**NOTE**:_这种模式可能很有用，但是应该谨慎使用，因为 CMake 不会对重新定义的宏或函数进行警告。_

# 7.6 使用废弃函数、宏和变量

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-06 中找到。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

“废弃”是在不断发展的项目开发过程中一种重要机制，它向开发人员发出信号，表明将来某个函数、宏或变量将被删除或替换。在一段时间内，函数、宏或变量将继续可访问，但会发出警告，最终可能会上升为错误。

## 准备工作

我们将从以下 CMake 项目开始:

```
cmake_minimum_required(VERSION 3.5 FATAL_ERROR)

project(recipe-06 LANGUAGES NONE)

macro(custom_include_guard)
  if(NOT DEFINED included_modules)
  	set(included_modules)
  endif()

  if ("${CMAKE_CURRENT_LIST_FILE}" IN_LIST included_modules)
  	message(WARNING "module ${CMAKE_CURRENT_LIST_FILE} processed more than once")
  endif()

  list(APPEND included_modules ${CMAKE_CURRENT_LIST_FILE})
endmacro()

include(cmake/custom.cmake)

message(STATUS "list of all included modules: ${included_modules}")
```

这段代码定义了一个自定义的”包含保护”机制，包括一个自定义模块(与前一个示例中的模块相同)，并打印所有包含模块的列表。对于 CMake 3.10 或更高版本有内置的`include_guard`。但是，不能简单地删除`custom_include_guard`和`${included_modules}`，而是使用一个“废弃”警告来弃用宏和变量。某个时候，可以将该警告转换为`FATAL_ERROR`，使代码停止配置，并迫使开发人员对代码进行修改，切换到内置命令。

## 具体实施

“废弃”函数、宏和变量的方法如下:

1. 首先，定义一个函数，我们将使用它来弃用一个变量:

   ```
   function(deprecate_variable _variable _access)
     if(_access STREQUAL "READ_ACCESS")
     	message(DEPRECATION "variable ${_variable} is deprecated")
     endif()
   endfunction()
   ```

2. 然后，如果 CMake 的版本大于 3.9，我们重新定义`custom_include_guard`并将`variable_watch`附加到`included_modules`中:

   ```
   if (CMAKE_VERSION VERSION_GREATER "3.9")
     # deprecate custom_include_guard
     macro(custom_include_guard)
       message(DEPRECATION "custom_include_guard is deprecated - use built-in include_guard instead")
       _custom_include_guard(${ARGV})
     endmacro()

     # deprecate variable included_modules
     variable_watch(included_modules deprecate_variable)
   endif()
   ```

3. CMake3.10 以下版本的项目会产生以下结果:

   ```
   $ mkdir -p build
   $ cd build
   $ cmake ..

   -- custom.cmake is included and processed
   -- list of all included modules: /home/user/example/cmake/custom.cmake
   ```

4. CMake 3.10 及以上将产生预期的“废弃”警告:

   ```
   CMake Deprecation Warning at CMakeLists.txt:26 (message):
   custom_include_guard is deprecated - use built-in include_guard instead
   Call Stack (most recent call first):
   cmake/custom.cmake:1 (custom_include_guard)
   CMakeLists.txt:34 (include)
   -- custom.cmake is included and processed
   CMake Deprecation Warning at CMakeLists.txt:19 (message):
   variable included_modules is deprecated
   Call Stack (most recent call first):
   CMakeLists.txt:9999 (deprecate_variable)
   CMakeLists.txt:36 (message)
   -- list of all included modules: /home/user/example/cmake/custom.cmake
   ```

## 工作原理

弃用函数或宏相当于重新定义它，如前面的示例所示，并使用`DEPRECATION`打印消息:

```
macro(somemacro)
  message(DEPRECATION "somemacro is deprecated")
  _somemacro(${ARGV})
endmacro()
```

可以通过定义以下变量来实现对变量的弃用:

```
function(deprecate_variable _variable _access)
  if(_access STREQUAL "READ_ACCESS")
  	message(DEPRECATION "variable ${_variable} is deprecated")
  endif()
endfunction()
```

然后，这个函数被添加到将要“废弃”的变量上:

```
variable_watch(somevariable deprecate_variable)
```

如果在本例中`${included_modules}`是读取 (`READ_ACCESS`)，那么`deprecate_variable`函数将发出带有`DEPRECATION`的消息。

# 7.7 add_subdirectory 的限定范围

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-07 中找到，其中有一个 C++示例。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

本章剩下的示例中，我们将讨论构建项目的策略，并限制变量的范围和副作用，目的是降低代码的复杂性和简化项目的维护。这个示例中，我们将把一个项目分割成几个范围有限的 CMakeLists.txt 文件，这些文件将使用`add_subdirectory`命令进行处理。

## 准备工作

由于我们希望展示和讨论如何构造一个复杂的项目，所以需要一个比“hello world”项目更复杂的例子:

- https://en.wikipedia.org/wiki/Cellular_automaton#Elementary_cellular_automata
- http://mathworld.wolfram.com/ElementaryCellularAutomaton.html

我们的代码将能够计算任何 256 个基本细胞自动机，例如：规则 90 (Wolfram 代码):

我们示例代码项目的结构如下:

```
.
├── CMakeLists.txt
├── external
│    ├── CMakeLists.txt
│    ├── conversion.cpp
│    ├── conversion.hpp
│    └── README.md
├── src
│    ├── CMakeLists.txt
│    ├── evolution
│    │    ├── CMakeLists.txt
│    │    ├── evolution.cpp
│    │    └── evolution.hpp
│    ├── initial
│    │    ├── CMakeLists.txt
│    │    ├── initial.cpp
│    │    └── initial.hpp
│    ├── io
│    │    ├── CMakeLists.txt
│    │    ├── io.cpp
│    │    └── io.hpp
│    ├── main.cpp
│    └── parser
│        ├── CMakeLists.txt
│        ├── parser.cpp
│        └── parser.hpp
└── tests
    ├── catch.hpp
    ├── CMakeLists.txt
    └── test.cpp
```

我们将代码分成许多库来模拟真实的大中型项目，可以将源代码组织到库中，然后将库链接到可执行文件中。

主要功能在`src/main.cpp`中:

```
#include "conversion.hpp"
#include "evolution.hpp"
#include "initial.hpp"
#include "io.hpp"
#include "parser.hpp"

#include <iostream>

int main(int argc, char *argv[]) {
  // parse arguments
  int length, num_steps, rule_decimal;
  std::tie(length, num_steps, rule_decimal) = parse_arguments(argc, argv);

  // print information about parameters
  std::cout << "length: " << length << std::endl;
  std::cout << "number of steps: " << num_steps << std::endl;
  std::cout << "rule: " << rule_decimal << std::endl;

  // obtain binary representation for the rule
  std::string rule_binary = binary_representation(rule_decimal);

  // create initial distribution
  std::vector<int> row = initial_distribution(length);

  // print initial configuration
  print_row(row);

  // the system evolves, print each step
  for (int step = 0; step < num_steps; step++) {
    row = evolve(row, rule_binary);
    print_row(row);
  }
}
```

`external/conversion.cpp`文件包含要从十进制转换为二进制的代码。

我们在这里模拟这段代码是由`src`外部的“外部”库提供的:

```
#include "conversion.hpp"
#include <bitset>
#include <string>
std::string binary_representation(const int decimal) {
	return std::bitset<8>(decimal).to_string();
}
```

`src/evolution/evolution.cpp`文件为一个时限传播系统:

```
#include "evolution.hpp"

#include <string>
#include <vector>

std::vector<int> evolve(const std::vector<int> row, const std::string rule_binary) {
  std::vector<int> result;

  for (auto i = 0; i < row.size(); ++i) {
    auto left = (i == 0 ? row.size() : i) - 1;
    auto center = i;
    auto right = (i + 1) % row.size();
    auto ancestors = 4 * row[left] + 2 * row[center] + 1 * row[right];
    ancestors = 7 - ancestors;
    auto new_state = std::stoi(rule_binary.substr(ancestors, 1));
    result.push_back(new_state);
  }
  return result;
}
```

`src/initial/initial.cpp`文件，对出进行初始化:

```
#include "initial.hpp"

#include <vector>

std::vector<int> initial_distribution(const int length) {

  // we start with a vector which is zeroed out
  std::vector<int> result(length, 0);

  // more or less in the middle we place a living cell
  result[length / 2] = 1;

  return result;
}
```

`src/io/io.cpp`文件包含一个函数输出打印行:

```
#include "io.hpp"
#include <algorithm>
#include <iostream>
#include <vector>
void print_row(const std::vector<int> row) {
  std::for_each(row.begin(), row.end(), [](int const &value) {
  	std::cout << (value == 1 ? '*' : ' ');
  });
  std::cout << std::endl;
}
```

`src/parser/parser.cpp`文件解析命令行输入:

```
#include "parser.hpp"

#include <cassert>
#include <string>
#include <tuple>

std::tuple<int, int, int> parse_arguments(int argc, char *argv[]) {
  assert(argc == 4 && "program called with wrong number of arguments");

  auto length = std::stoi(argv[1]);
  auto num_steps = std::stoi(argv[2]);
  auto rule_decimal = std::stoi(argv[3]);

  return std::make_tuple(length, num_steps, rule_decimal);
}
```

最后，`tests/test.cpp`包含两个使用 Catch2 库的单元测试:

```
#include "evolution.hpp"

// this tells catch to provide a main()
// only do this in one cpp file
#define CATCH_CONFIG_MAIN
#include "catch.hpp"

#include <string>
#include <vector>

TEST_CASE("Apply rule 90", "[rule-90]") {
  std::vector<int> row = {0, 1, 0, 1, 0, 1, 0, 1, 0};
  std::string rule = "01011010";
  std::vector<int> expected_result = {1, 0, 0, 0, 0, 0, 0, 0, 1};
  REQUIRE(evolve(row, rule) == expected_result);
}

TEST_CASE("Apply rule 222", "[rule-222]") {
  std::vector<int> row = {0, 0, 0, 0, 1, 0, 0, 0, 0};
  std::string rule = "11011110";
  std::vector<int> expected_result = {0, 0, 0, 1, 1, 1, 0, 0, 0};
  REQUIRE(evolve(row, rule) == expected_result);
}
```

相应的头文件包含函数声明。有人可能会说，对于这个小代码示例，项目包含了太多子目录。请注意，这只是一个项目的简化示例，通常包含每个库的许多源文件，理想情况下，这些文件被放在到单独的目录中。

## 具体实施

让我们来详细解释一下 CMake 所需的功能:

1. `CMakeLists.txt`顶部非常类似于第 1 节，代码重用与函数和宏:

   ```
   cmake_minimum_required(VERSION 3.5 FATAL_ERROR)

   project(recipe-07 LANGUAGES CXX)

   set(CMAKE_CXX_STANDARD 11)
   set(CMAKE_CXX_EXTENSIONS OFF)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)

   include(GNUInstallDirs)
   set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_LIBRARY_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_RUNTIME_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})

   # defines targets and sources
   add_subdirectory(src)

   # contains an "external" library we will link to
   add_subdirectory(external)

   # enable testing and define tests
   enable_testing()
   add_subdirectory(tests)
   ```

2. 目标和源在`src/CMakeLists.txt`中定义(转换目标除外):

   ```
   add_executable(automata main.cpp)

   add_subdirectory(evolution)
   add_subdirectory(initial)
   add_subdirectory(io)
   add_subdirectory(parser)

   target_link_libraries(automata
     PRIVATE
       conversion
       evolution
       initial
       io
       parser
     )
   ```

3. 转换库在`external/CMakeLists.txt`中定义:

   ```
   add_library(conversion "")

   target_sources(conversion
     PRIVATE
       ${CMAKE_CURRENT_LIST_DIR}/conversion.cpp
     PUBLIC
       ${CMAKE_CURRENT_LIST_DIR}/conversion.hpp
     )

   target_include_directories(conversion
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}
     )
   ```

4. `src/CMakeLists.txt`文件添加了更多的子目录，这些子目录又包含`CMakeLists.txt`文件。`src/evolution/CMakeLists.txt`包含以下内容:

   ```
   add_library(evolution "")

   target_sources(evolution
     PRIVATE
     	evolution.cpp
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}/evolution.hpp
     )

   target_include_directories(evolution
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}
     )
   ```

5. 单元测试在`tests/CMakeLists.txt`中注册:

   ```
   add_executable(cpp_test test.cpp)

   target_link_libraries(cpp_test evolution)

   add_test(
     NAME
     	test_evolution
     COMMAND
     	$<TARGET_FILE:cpp_test>
     )
   ```

6. 配置和构建项目产生以下输出:

   ```
   $ mkdir -p build
   $ cd build
   $ cmake ..
   $ cmake --build .

   Scanning dependencies of target conversion
   [ 7%] Building CXX object external/CMakeFiles/conversion.dir/conversion.cpp.o
   [ 14%] Linking CXX static library ../lib64/libconversion.a
   [ 14%] Built target conversion
   Scanning dependencies of target evolution
   [ 21%] Building CXX object src/evolution/CMakeFiles/evolution.dir/evolution.cpp.o
   [ 28%] Linking CXX static library ../../lib64/libevolution.a
   [ 28%] Built target evolution
   Scanning dependencies of target initial
   [ 35%] Building CXX object src/initial/CMakeFiles/initial.dir/initial.cpp.o
   [ 42%] Linking CXX static library ../../lib64/libinitial.a
   [ 42%] Built target initial
   Scanning dependencies of target io
   [ 50%] Building CXX object src/io/CMakeFiles/io.dir/io.cpp.o
   [ 57%] Linking CXX static library ../../lib64/libio.a
   [ 57%] Built target io
   Scanning dependencies of target parser
   [ 64%] Building CXX object src/parser/CMakeFiles/parser.dir/parser.cpp.o
   [ 71%] Linking CXX static library ../../lib64/libparser.a
   [ 71%] Built target parser
   Scanning dependencies of target automata
   [ 78%] Building CXX object src/CMakeFiles/automata.dir/main.cpp.o
   [ 85%] Linking CXX executable ../bin/automata
   [ 85%] Built target automata
   Scanning dependencies of target cpp_test
   [ 92%] Building CXX object tests/CMakeFiles/cpp_test.dir/test.cpp.o
   [100%] Linking CXX executable ../bin/cpp_test
   [100%] Built target cpp_test
   ```

7. 最后，运行单元测试:

   ```
   $ ctest

   Running tests...
   Start 1: test_evolution
   1/1 Test #1: test_evolution ................... Passed 0.00 sec
   100% tests passed, 0 tests failed out of 1
   ```

## 工作原理

我们可以将所有代码放到一个源文件中。不过，每次编辑都需要重新编译。将源文件分割成更小、更易于管理的单元是有意义的。可以将所有源代码都编译成一个库或可执行文件。实际上，项目更喜欢将源代码编译分成更小的、定义良好的库。这样做既是为了本地化和简化依赖项，也是为了简化代码维护。这意味着如在这里所做的那样，由许多库构建一个项目是一种常见的情况。

为了讨论 CMake 结构，我们可以从定义每个库的单个 CMakeLists.txt 文件开始，自底向上进行，例如`src/evolution/CMakeLists.txt`:

```
add_library(evolution "")

target_sources(evolution
  PRIVATE
  	evolution.cpp
  PUBLIC
  	${CMAKE_CURRENT_LIST_DIR}/evolution.hpp
  )

target_include_directories(evolution
  PUBLIC
  	${CMAKE_CURRENT_LIST_DIR}
  )
```

这些单独的`CMakeLists.txt`文件定义了库。本例中，我们首先使用`add_library`定义库名，然后定义它的源和包含目录，以及它们的目标可见性：实现文件(`evolution.cpp`:`PRIVATE`)，而接口头文件`evolution.hpp`定义为`PUBLIC`，因为我们将在`main.cpp`和`test.cpp`中访问它。定义尽可能接近代码目标的好处是，对于该库的修改，只需要变更该目录中的文件即可；换句话说，也就是库依赖项被封装。

向上移动一层，库在`src/CMakeLists.txt`中封装:

```
add_executable(automata main.cpp)

add_subdirectory(evolution)
add_subdirectory(initial)
add_subdirectory(io)
add_subdirectory(parser)

target_link_libraries(automata
  PRIVATE
    conversion
    evolution
    initial
    io
    parser
  )
```

文件在主`CMakeLists.txt`中被引用。这意味着使用`CMakeLists.txt`文件，构建我们的项目。这种方法对于许多项目来说是可用的，并且它可以扩展到更大型的项目，而不需要在目录间的全局变量中包含源文件列表。`add_subdirectory`方法的另一个好处是它隔离了作用范围，因为子目录中定义的变量在父范围中不能访问。

## 更多信息

使用`add_subdirectory`调用树构建项目的一个限制是，CMake 不允许将`target_link_libraries`与定义在当前目录范围之外的目标一起使用。对于本示例来说，这不是问题。在下一个示例中，我们将演示另一种方法，我们不使用`add_subdirectory`，而是使用`module include`来组装不同的`CMakeLists.txt`文件，它允许我们链接到当前目录之外定义的目标。

CMake 可以使用 Graphviz 图形可视化软件([http://www.graphviz.org](http://www.graphviz.org/) )生成项目的依赖关系图:

```
$ cd build
$ cmake --graphviz=example.dot ..
$ dot -T png example.dot -o example.png
```

本书中，我们一直在构建源代码之外的代码，以保持源代码树和构建树是分开的。这是推荐的方式，允许我们使用相同的源代码配置不同的构建(顺序的或并行的，Debug 或 Release)，而不需要复制源代码，也不需要在源代码树中生成目标文件。使用以下代码片段，可以保护您的项目免受内部构建的影响:

```
if(${PROJECT_SOURCE_DIR} STREQUAL ${PROJECT_BINARY_DIR})
	message(FATAL_ERROR "In-source builds not allowed. Please make a new directory (called a build directory) and run CMake from there.")
endif()
```

认识到构建结构与源结构类似很有用。示例中，将`message`打印输出插入到`src/CMakeLists.txt`中:

```
message("current binary dir is ${CMAKE_CURRENT_BINARY_DIR}")
```

在`build`下构建项目时，我们将看到`build/src`的打印输出。

在 CMake 的 3.12 版本中，`OBJECT`库是组织大型项目的另一种可行方法。对我们的示例的惟一修改是在库的`CMakeLists.tx`t 中。源文件将被编译成目标文件：既不存档到静态库中，也不链接到动态库中。例如：

```
add_library(io OBJECT "")

target_sources(io
  PRIVATE
  	io.cpp
  PUBLIC
  	${CMAKE_CURRENT_LIST_DIR}/io.hpp
  )

target_include_directories(io
  PUBLIC
  	${CMAKE_CURRENT_LIST_DIR}
  )
```

主`CMakeLists.txt`保持不变:`automata`可执行目标将这些目标文件链接到最终的可执行文件。使用也有要求需求，例如：在对象库上设置的目录、编译标志和链接库，将被正确地继承。有关 CMake 3.12 中引入的对象库新特性的更多细节，请参考官方文档: https://cmake.org/cmake/help/v3.12/manual/cmake-buildsystem.7.html#object-libraries

# 7.8 使用 target_sources 避免全局变量

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-08 中找到，其中有一个 C++示例。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

本示例中，我们将讨论前一个示例的另一种方法，并不使用`add_subdirectory`的情况下，使用`module include`组装不同的 CMakeLists.txt 文件。这种方法的灵感来自https://crascit.com/2016/01/31/enhance-sours-file-handling-with-target_sources/ ，其允许我们使用`target_link_libraries`链接到当前目录之外定义的目标。

## 准备工作

将使用与前一个示例相同的源代码。惟一的更改将出现在`CMakeLists.txt`文件中，我们将在下面的部分中讨论这些更改。

## 具体实施

1. 主`CMakeLists.txt`包含以下内容:

   ```
   cmake_minimum_required(VERSION 3.5 FATAL_ERROR)

   project(recipe-08 LANGUAGES CXX)

   set(CMAKE_CXX_STANDARD 11)
   set(CMAKE_CXX_EXTENSIONS OFF)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)

   include(GNUInstallDirs)
   set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_LIBRARY_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_RUNTIME_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})

   # defines targets and sources
   include(src/CMakeLists.txt)
   include(external/CMakeLists.txt)

   enable_testing()
   add_subdirectory(tests)
   ```

2. 与前一个示例相比，`external/CMakeLists.txt`文件没有变化。

3. `src/CMakeLists.txt`文件定义了两个库(automaton 和 evolution):

   ```
   add_library(automaton "")
   add_library(evolution "")

   include(${CMAKE_CURRENT_LIST_DIR}/evolution/CMakeLists.txt)
   include(${CMAKE_CURRENT_LIST_DIR}/initial/CMakeLists.txt)
   include(${CMAKE_CURRENT_LIST_DIR}/io/CMakeLists.txt)
   include(${CMAKE_CURRENT_LIST_DIR}/parser/CMakeLists.txt)

   add_executable(automata "")

   target_sources(automata
     PRIVATE
     	${CMAKE_CURRENT_LIST_DIR}/main.cpp
     )

   target_link_libraries(automata
     PRIVATE
       automaton
       conversion
     )
   ```

4. `src/evolution/CMakeLists.txt`文件包含以下内容:

   ```
   target_sources(automaton
     PRIVATE
     	${CMAKE_CURRENT_LIST_DIR}/evolution.cpp
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}/evolution.hpp
     )

   target_include_directories(automaton
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}
     )

   target_sources(evolution
     PRIVATE
     	${CMAKE_CURRENT_LIST_DIR}/evolution.cpp
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}/evolution.hpp
     )

   target_include_directories(evolution
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}
     )
   ```

5. 其余`CMakeLists.txt`文件和`src/initial/CMakeLists.txt`相同:

   ```
   target_sources(automaton
     PRIVATE
     	${CMAKE_CURRENT_LIST_DIR}/initial.cpp
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}/initial.hpp
     )

   target_include_directories(automaton
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}
     )
   ```

6. 配置、构建和测试的结果与前面的方法相同:

   ```
   $ mkdir -p build
   $ cd build
   $ cmake ..
   $ cmake --build build
   $ ctest

   Running tests...
   Start 1: test_evolution
   1/1 Test #1: test_evolution ................... Passed 0.00 sec
   100% tests passed, 0 tests failed out of 1
   ```

## 工作原理

与之前的示例不同，我们定义了三个库:

- conversion(在 external 定义)
- automaton(包含除转换之外的所有源)
- evolution(在`src/evolution`中定义，并通过`cpp_test`链接)

本例中，通过使用`include()`引用`CMakeLists.txt`文件，我们在父范围内，仍然能保持所有目标可用:

```
include(src/CMakeLists.txt)
include(external/CMakeLists.txt)
```

我们可以构建一个包含树，记住当进入子目录(`src/CMakeLists.txt`)时，我们需要使用相对于父范围的路径:

```
include(${CMAKE_CURRENT_LIST_DIR}/evolution/CMakeLists.txt)
include(${CMAKE_CURRENT_LIST_DIR}/initial/CMakeLists.txt)
include(${CMAKE_CURRENT_LIST_DIR}/io/CMakeLists.txt)
include(${CMAKE_CURRENT_LIST_DIR}/parser/CMakeLists.txt)
```

这样，我们就可以定义并链接到通过`include()`语句访问文件树中任何位置的目标。但是，我们应该选择在对维护人员和代码贡献者容易看到的地方，去定义它们。

## 更多信息

我们可以再次使用 CMake 和 Graphviz (http://www.graphviz.org/)生成这个项目的依赖关系图:

```
$ cd build
$ cmake --graphviz=example.dot ..
$ dot -T png example.dot -o example.png
```

# 7.9 组织 Fortran 项目

**NOTE**:_此示例代码可以在 https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-7/recipe-09 中找到，其中有一个 Fortran 示例。该示例在 CMake 3.5 版(或更高版本)中是有效的，并且已经在 GNU/Linux、macOS 和 Windows 上进行过测试。_

我们来讨论如何构造和组织 Fortran 项目，原因有二:

1. 现在，仍然有很多 Fortran 项目，特别是在数字软件中(有关通用 Fortran 软件项目的更全面列表，请参见http://fortranwiki.org/fortran/show/Libraries )。
2. 对于不使用 CMake 的项目，Fortran 90(以及更高版本)可能更难构建，因为 Fortran 模块强制执行编译顺序。换句话说，对于手工编写的 Makefile，通常需要为 Fortran 模块文件编写依赖扫描程序。

正如我们在本示例中所示，现代 CMake 允许我们以非常紧凑和模块化的方式配置和构建项目。作为一个例子，我们将使用前两个示例中的基本元胞自动机，现在将其移植到 Fortran。

## 准备工作

文件树结构与前两个示例非常相似。我们用 Fortran 源代码替换了 C++，现在就没有头文件了:

```
.
├── CMakeLists.txt
├── external
│    ├── CMakeLists.txt
│    ├── conversion.f90
│    └── README.md
├── src
│    ├── CMakeLists.txt
│    ├── evolution
│    │    ├── ancestors.f90
│    │    ├── CMakeLists.txt
│    │    ├── empty.f90
│    │    └── evolution.f90
│    ├── initial
│    │    ├── CMakeLists.txt
│    │    └── initial.f90
│    ├── io
│    │    ├── CMakeLists.txt
│    │    └── io.f90
│    ├── main.f90
│    └── parser
│        ├── CMakeLists.txt
│        └── parser.f90
└── tests
    ├── CMakeLists.txt
    └── test.f90
```

主程序在`src/main.f90`中:

```
program example

  use parser, only: get_arg_as_int
  use conversion, only: binary_representation
  use initial, only: initial_distribution
  use io, only: print_row
  use evolution, only: evolve

  implicit none

  integer :: num_steps
  integer :: length
  integer :: rule_decimal
  integer :: rule_binary(8)
  integer, allocatable :: row(:)
  integer :: step

  ! parse arguments
  num_steps = get_arg_as_int(1)
  length = get_arg_as_int(2)
  rule_decimal = get_arg_as_int(3)

  ! print information about parameters
  print *, "number of steps: ", num_steps
  print *, "length: ", length
  print *, "rule: ", rule_decimal

  ! obtain binary representation for the rule
  rule_binary = binary_representation(rule_decimal)

  ! create initial distribution
  allocate(row(length))
  call initial_distribution(row)

  ! print initial configuration
  call print_row(row)

  ! the system evolves, print each step
  do step = 1, num_steps
    call evolve(row, rule_binary)
    call print_row(row)
  end do

  deallocate(row)
end program
```

与前面的示例一样，我们已经将 conversion 模块放入`external/conversion.f90`中：

```
module conversion

  implicit none
  public binary_representation
  private

contains

  pure function binary_representation(n_decimal)
    integer, intent(in) :: n_decimal
    integer :: binary_representation(8)
    integer :: pos
    integer :: n

    binary_representation = 0
    pos = 8
    n = n_decimal
    do while (n > 0)
      binary_representation(pos) = mod(n, 2)
      n = (n - binary_representation(pos))/2
      pos = pos - 1
    end do
  end function

end module
```

evolution 库分成三个文件，大部分在`src/evolution/evolution.f90`中:

```
module evolution

  implicit none
  public evolve
  private

contains

  subroutine not_visible()
    ! no-op call to demonstrate private/public visibility
    call empty_subroutine_no_interface()
  end subroutine

  pure subroutine evolve(row, rule_binary)
    use ancestors, only: compute_ancestors

    integer, intent(inout) :: row(:)
    integer, intent(in) :: rule_binary(8)
    integer :: i
    integer :: left, center, right
    integer :: ancestry
    integer, allocatable :: new_row(:)

    allocate(new_row(size(row)))

    do i = 1, size(row)
      left = i - 1
      center = i
      right = i + 1

      if (left < 1) left = left + size(row)
      if (right > size(row)) right = right - size(row)

      ancestry = compute_ancestors(row, left, center, right)
      new_row(i) = rule_binary(ancestry)
    end do

    row = new_row
    deallocate(new_row)

  end subroutine

end module
```

祖先计算是在`src/evolution/ancestors.f90`：

```
module ancestors

  implicit none
  public compute_ancestors
  private

  contains
  pure integer function compute_ancestors(row, left, center, right) result(i)
    integer, intent(in) :: row(:)
    integer, intent(in) :: left, center, right

    i = 4*row(left) + 2*row(center) + 1*row(right)
    i = 8 - i
  end function
end module
```

还有一个“空”模块在`src/evolution/empty.f90`中：

```
module empty

  implicit none
  public empty_subroutine
  private

contains

  subroutine empty_subroutine()
  end subroutine

end module

subroutine
empty_subroutine_no_interface()
  use empty, only: empty_subroutine
  call empty_subroutine()
end subroutine
```

启动条件的代码位于`src/initial/initial.f90`：

```
module initial

  implicit none
  public initial_distribution
  private

contains

	pure subroutine initial_distribution(row)
    integer, intent(out) :: row(:)

    row = 0
    row(size(row)/2) = 1
	end subroutine

end module
```

`src/io/io.f90`包含一个打印输出：

```
module io

  implicit none
  public print_row
  private

  contains

  subroutine print_row(row)
    integer, intent(in) :: row(:)
    character(size(row)) :: line
    integer :: i

    do i = 1, size(row)
      if (row(i) == 1) then
      	line(i:i) = '*'
      else
      	line(i:i) = ' '
      end if
    end do

    print *, line
  end subroutine

end module
```

`src/parser/parser.f90`用于解析命令行参数：

```
module parser

  implicit none
  public get_arg_as_int
  private

  contains

  integer function get_arg_as_int(n) result(i)
    integer, intent(in) :: n
    character(len=32) :: arg

    call get_command_argument(n, arg)
    read(arg , *) i
  end function
end module
```

最后，使用`tests/test.f90`对上面的实现进行测试：

```
program test

  use evolution, only: evolve

  implicit none

  integer :: row(9)
  integer :: expected_result(9)
  integer :: rule_binary(8)
  integer :: i

  ! test rule 90
  row = (/0, 1, 0, 1, 0, 1, 0, 1, 0/)
  rule_binary = (/0, 1, 0, 1, 1, 0, 1, 0/)
  call evolve(row, rule_binary)
  expected_result = (/1, 0, 0, 0, 0, 0, 0, 0, 1/)
  do i = 1, 9
  	if (row(i) /= expected_result(i)) then
  		print *, 'ERROR: test for rule 90 failed'
  		call exit(1)
  	end if
  end do

  ! test rule 222
  row = (/0, 0, 0, 0, 1, 0, 0, 0, 0/)
  rule_binary = (/1, 1, 0, 1, 1, 1, 1, 0/)
  call evolve(row, rule_binary)
  expected_result = (/0, 0, 0, 1, 1, 1, 0, 0, 0/)
  do i = 1, 9
  	if (row(i) /= expected_result(i)) then
  		print *, 'ERROR: test for rule 222 failed'
  		call exit(1)
  	end if
  end do
end program
```

## 具体实施

1. 主`CMakeLists.txt`类似于第 7 节，我们只是将 CXX 换成 Fortran，去掉 C++11 的要求:

   ```
   cmake_minimum_required(VERSION 3.5 FATAL_ERROR)

   project(recipe-09 LANGUAGES Fortran)

   include(GNUInstallDirs)
   set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_LIBRARY_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})
   set(CMAKE_RUNTIME_OUTPUT_DIRECTORY
   ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})

   # defines targets and sources
   add_subdirectory(src)

   # contains an "external" library we will link to
   add_subdirectory(external)

   # enable testing and define tests
   enable_testing()
   add_subdirectory(tests)
   ```

2. 目标和源在`src/CMakeLists.txt`中定义(conversion 目标除外):

   ```
   add_executable(automata main.f90)

   add_subdirectory(evolution)
   add_subdirectory(initial)
   add_subdirectory(io)
   add_subdirectory(parser)

   target_link_libraries(automata
     PRIVATE
       conversion
       evolution
       initial
       io
       parser
     )
   ```

3. conversion 库在`external/CMakeLists.txt`中定义:

   ```
   add_library(conversion "")

   target_sources(conversion
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}/conversion.f90
     )
   ```

4. `src/CMakeLists.txt`文件添加了更多的子目录，这些子目录又包含`CMakeLists.txt`文件。它们在结构上都是相似的，例如：`src/initial/CMakeLists.txt`包含以下内容:

   ```
   add_library(initial "")

   target_sources(initial
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}/initial.f90
     )
   ```

5. 有个例外的是`src/evolution/CMakeLists.txt`中的 evolution 库，我们将其分为三个源文件:

   ```
   add_library(evolution "")

   target_sources(evolution
     PRIVATE
     	empty.f90
     PUBLIC
     	${CMAKE_CURRENT_LIST_DIR}/ancestors.f90
     	${CMAKE_CURRENT_LIST_DIR}/evolution.f90
     )
   ```

6. 单元测试在`tests/CMakeLists.txt`中注册:

   ```
   add_executable(fortran_test test.f90)

   target_link_libraries(fortran_test evolution)

   add_test(
     NAME
     	test_evolution
     COMMAND
     	$<TARGET_FILE:fortran_test>
     )
   ```

7. 配置和构建项目，将产生以下输出:

   ```
   $ mkdir -p build
   $ cd build
   $ cmake ..
   $ cmake --build .
   Scanning dependencies of target conversion
   [ 4%] Building Fortran object external/CMakeFiles/conversion.dir/conversion.f90.o
   [ 8%] Linking Fortran static library ../lib64/libconversion.a
   [ 8%] Built target conversion
   Scanning dependencies of target evolution
   [ 12%] Building Fortran object src/evolution/CMakeFiles/evolution.dir/ancestors.f90.o
   [ 16%] Building Fortran object src/evolution/CMakeFiles/evolution.dir/empty.f90.o
   [ 20%] Building Fortran object src/evolution/CMakeFiles/evolution.dir/evolution.f90.o
   [ 25%] Linking Fortran static library ../../lib64/libevolution.a
   [ 25%] Built target evolution
   Scanning dependencies of target initial
   [ 29%] Building Fortran object src/initial/CMakeFiles/initial.dir/initial.f90.o
   [ 33%] Linking Fortran static library ../../lib64/libinitial.a
   [ 33%] Built target initial
   Scanning dependencies of target io
   [ 37%] Building Fortran object src/io/CMakeFiles/io.dir/io.f90.o
   [ 41%] Linking Fortran static library ../../lib64/libio.a
   [ 41%] Built target io
   Scanning dependencies of target parser
   [ 45%] Building Fortran object src/parser/CMakeFiles/parser.dir/parser.f90.o
   [ 50%] Linking Fortran static library ../../lib64/libparser.a
   [ 50%] Built target parser
   Scanning dependencies of target example
   [ 54%] Building Fortran object src/CMakeFiles/example.dir/__/external/conversion.f90.o
   [ 58%] Building Fortran object src/CMakeFiles/example.dir/evolution/ancestors.f90.o
   [ 62%] Building Fortran object src/CMakeFiles/example.dir/evolution/evolution.f90.o
   [ 66%] Building Fortran object src/CMakeFiles/example.dir/initial/initial.f90.o
   [ 70%] Building Fortran object src/CMakeFiles/example.dir/io/io.f90.o
   [ 75%] Building Fortran object src/CMakeFiles/example.dir/parser/parser.f90.o
   [ 79%] Building Fortran object src/CMakeFiles/example.dir/main.f90.o
   [ 83%] Linking Fortran executable ../bin/example
   [ 83%] Built target example
   Scanning dependencies of target fortran_test
   [ 87%] Building Fortran object tests/CMakeFiles/fortran_test.dir/__/src/evolution/ancestors.f90.o
   [ 91%] Building Fortran object tests/CMakeFiles/fortran_test.dir/__/src/evolution/evolution.f90.o
   [ 95%] Building Fortran object tests/CMakeFiles/fortran_test.dir/test.f90.o
   [100%] Linking Fortran executable
   ```

8. 最后，运行单元测试：

   ```
   $ ctest

   Running tests...
   Start 1: test_evolution
   1/1 Test #1: test_evolution ................... Passed 0.00 sec

   100% tests passed, 0 tests failed out of 1
   ```

## 工作原理

第 7 节中使用`add_subdirectory`限制范围，将从下往上讨论 CMake 结构，从定义每个库的单个`CMakeLists.txt`文件开始，比如`src/evolution/CMakeLists.txt`:

```
add_library(evolution "")
target_sources(evolution
  PRIVATE
  	empty.f90
  PUBLIC
    ${CMAKE_CURRENT_LIST_DIR}/ancestors.f90
    ${CMAKE_CURRENT_LIST_DIR}/evolution.f90
  )
```

这些独立的`CMakeLists.txt`文件定义了源文件的库，遵循与前两个示例相同的方式：开发或维护人员可以对其中文件分而治之。

首先用`add_library`定义库名，然后定义它的源和包含目录，以及它们的目标可见性。这种情况下，因为它们的模块接口是在库之外访问，所以`ancestors.f90`和`evolution.f90`都是`PUBLIC`，而模块接口`empty.f90`不能在文件之外访问，因此将其标记为`PRIVATE`。

向上移动一层，库在`src/CMakeLists.txt`中封装：

```
add_executable(automata main.f90)

add_subdirectory(evolution)
add_subdirectory(initial)
add_subdirectory(io)
add_subdirectory(parser)

target_link_libraries(automata
  PRIVATE
    conversion
    evolution
    initial
    io
    parser
  )
```

这个文件在主`CMakeLists.txt`中被引用。这意味着我们使用`CMakeLists.txt`文件(使用`add_subdirectory`添加)构建项目。正如第 7 节中讨论的，使用`add_subdirectory`限制范围，这种方法可以扩展到更大型的项目，而不需要在多个目录之间的全局变量中携带源文件列表，还可以隔离范围和名称空间。

将这个 Fortran 示例与 C++版本(第 7 节)进行比较，我们可以注意到，在 Fortran 的情况下，相对的 CMake 工作量比较小；我们不需要使用`target_include_directory`，因为没有头文件，接口是通过生成的 Fortran 模块文件进行通信。另外，我们既不需要担心`target_sources`中列出的源文件的顺序，也不需要在库之间强制执行任何显式依赖关系。CMake 能够从源文件依赖项推断 Fortran 模块依赖项。使用`target_sources`与`PRIVATE`和`PUBLIC`资源结合使用，以紧凑和健壮的方式表示接口。

## 更多信息

这个示例中，我们没有指定应该放置 Fortran 模块文件的目录，并且保持了这个透明。模块文件的位置可以通过设置`CMAKE_Fortran_MODULE_DIRECTORY`变量来指定。注意，也可以将其设置为`Fortran_MODULE_DIRECTORY`，从而实现更好的控制。详细可见：https://cmake.org/cmake/help/v3.5/prop_tgt/Fortran_MODULE_DIRECTORY.html
