# gcc

hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行 hello.c 程序，每条 C 语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：

```sh
unix> gcc -o hello hello.c
```

GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译的过程可分为四个阶段完成：

![image](https://user-images.githubusercontent.com/5803001/52256465-bce93280-2951-11e9-860c-5dba0ae2bcb2.png)

- 预处理阶段。预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的 #include <stdio.h> 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入到程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。

- 编译阶段。编译器（cc1）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C 编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。

- 汇编阶段。接下来，汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。如果我们在文本编辑器中打开 hello.o 文件，看到的将是一堆乱码。

- 链接阶段。请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都会提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。

# gcc 的组成

| 部分        | 描述                                                                                                                                                                               |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| c++         | gcc 的一个版木，默认语言设置为 [C++](http://c.biancheng.net/cplus/)，而且在连接的时候自动包含标准 C++ 库。这和 g++ 一样                                                            |
| ccl         | 实际的 C 编译程序                                                                                                                                                                  |
| cclplus     | 实际的 C++ 编泽程序                                                                                                                                                                |
| collect2    | 在不使用 GNU 连接程序的系统上，有必要运行 collect2 来产生特定的全局初始化代码（例如 C++ 的构造函数和析构函数）                                                                     |
| configure   | GCC 源代码树根目录中的一个脚木。用于设置配置值和创建 GCC 编译程序必需的 make 程序的描述文件                                                                                        |
| crt0.o      | 这个初始化和结束代码是为每个系统定制的，而且也被编译进该文件，该文件然后会被连接到每个可执行文件中来执行必要的启动和终止程序                                                       |
| cygwin1.dll | Windows 的共享库提供的 API，模拟 UNIX 系统调用                                                                                                                                     |
| f77         | 该驱动程序可用于编译 Fortran                                                                                                                                                       |
| f771        | 实际的 Fortran 编译程序                                                                                                                                                            |
| g++         | gcc 的一个版木，默认语言设置为 C++，而且在连接的时候自动包含标准 C++ 库。这和 c++ 一样                                                                                             |
| gcc         | 该驱动程序等同于执行编译程序和连接程序以产生需要的输出                                                                                                                             |
| gcj         | 该驱动程序用于编译 [Java](http://c.biancheng.net/java/)                                                                                                                            |
| gnat1       | 实际的 Ada 编译程序                                                                                                                                                                |
| gnatbind    | 一种工具，用于执行 Ada 语言绑定                                                                                                                                                    |
| gnatlink    | 一种工具，用于执行 Ada 语言连接                                                                                                                                                    |
| jc1         | 实际的 Java 编译程序                                                                                                                                                               |
| libgcc      | 该库包含的例程被作为编泽程序的一部分，是因为它们可被连接到实际的可执行程序中。它们是特殊的例程，连接到可执行程序，来执行基木的任务，例如浮点运算。这些库中的例程通常都是平台相关的 |
| libgcj      | 运行时库包含所有的核心 Java 类                                                                                                                                                     |
| libobjc     | 对所有 Objective-C 程序都必须的运行时库                                                                                                                                            |
| libstdc++   | 运行时库，包括定义为标准语言一部分的所有的 C++ 类和函数                                                                                                                            |
