# C++ 命名空间的演化

C++ 是在 C 语言的基础上开发的，早期的 C++ 还不完善，不支持命名空间，没有自己的编译器，而是将 C++ 代码翻译成 C 代码，再通过 C 编译器完成编译。这个时候的 C++ 仍然在使用 C 语言的库，stdio.h、stdlib.h、string.h 等头文件依然有效；此外 C++ 也开发了一些新的库，增加了自己的头文件，例如：

- iostream.h：用于控制台输入输出头文件。
- fstream.h：用于文件操作的头文件。
- complex.h：用于复数计算的头文件。

和 C 语言一样，C++ 头文件仍然以.h 为后缀，它们所包含的类、函数、宏等都是全局范围的。后来 C++ 引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间，这个命名空间的名字就是 std。std 是 standard 的缩写，意思是“标准命名空间”。但是这时已经有很多用老式 C++ 开发的程序了，它们的代码中并没有使用命名空间，直接修改原来的库会带来一个很严重的后果：程序员会因为不愿花费大量时间修改老式代码而极力反抗，拒绝使用新标准的 C++ 代码。C++ 开发人员想了一个好办法，保留原来的库和头文件，它们在 C++ 中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间 std 下，就成了新版 C++ 标准库。这样共存在了两份功能相似的库，使用了老式 C++ 的程序可以继续使用原来的库，新开发的程序可以使用新版的 C++ 库。

为了避免头文件重名，新版 C++ 库也对头文件的命名做了调整，去掉了后缀.h，所以老式 C++ 的 iostream.h 变成了 iostream，fstream.h 变成了 fstream。而对于原来 C 语言的头文件，也采用同样的方法，但在每个名字前还要添加一个 c 字母，所以 C 语言的 stdio.h 变成了 cstdio，stdlib.h 变成了 cstdlib。

需要注意的是，旧的 C++ 头文件是官方所反对使用的，已明确提出不再支持，但旧的 C 头文件仍然可以使用，以保持对 C 的兼容性。实际上，编译器开发商不会停止对客户现有软件提供支持，可以预计，旧的 C++ 头文件在未来数年内还是会被支持。

1. 旧的 C++ 头文件，如 iostream.h、fstream.h 等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容不在命名空间 std 中。
2. 新的 C++ 头文件，如 iostream、fstream 等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间 std 中。
3. 标准 C 头文件如 stdio.h、stdlib.h 等继续被支持。头文件的内容不在 std 中。
4. 具有 C 库功能的新 C++头文件具有如 cstdio、cstdlib 这样的名字。它们提供的内容和相应的旧的 C 头文件相同，只是内容在 std 中。

可以发现，对于不带.h 的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带.h 的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是 C++ 标准所规定的。不过现实情况和 C++ 标准所期望的有些不同，对于原来 C 语言的头文件，即使按照 C++ 的方式来使用，即#include <cstdio>这种形式，那么符号可以位于命名空间 std 中，也可以位于全局范围中，请看下面的两段代码。

1. 使用命名空间 std：

```cpp
#include <cstdio>
int main(){
    std::printf("http://c.biancheng.net\n");
    return 0;
}
```

2. 不使用命名空间 std：

```c
#include <cstdio>
int main(){
    printf("http://c.biancheng.net\n");
    return 0;
}
```

这两种形式在 Microsoft Visual C++ 和 [GCC](http://c.biancheng.net/gcc/) 下都能够编译通过，也就是说，大部分编译器在实现时并没有严格遵循 C++标准，它们对两种写法都支持，程序员可以使用 std 也可以不使用。

第 1 种写法是标准的，第 2 种不标准，虽然它们在目前的编译器中都没有错误，但我依然推荐使用第 1) 种写法，因为标准写法会一直被编译器支持，非标准写法可能会在以后的升级版本中不再支持。
