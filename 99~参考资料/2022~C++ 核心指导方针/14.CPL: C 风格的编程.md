# <a name="S-cpl"></a>CPL: C 风格的编程

C 和 C++ 是联系很紧密的两门语言。
它们都是源于 1978 年的“经典 C”语言的，且从此之后就在 ISO 标准委员会中进行演化。
为了让它们保持兼容，我们做过许多努力，但它们各自都并非是对方的子集。

C 规则概览：

- [CPL.1: 优先使用 C++ 而不是 C](#Rcpl-C)
- [CPL.2: 当一定要用 C 时，应使用 C 和 C++ 的公共子集，并将 C 代码以 C++ 来编译](#Rcpl-subset)
- [CPL.3: 当一定要用 C 来作为接口时，应在使用这些接口的调用方代码中使用 C++](#Rcpl-interface)

### <a name="Rcpl-C"></a>CPL.1: 优先使用 C++ 而不是 C

##### 理由

C++ 提供更好的类型检查和更多的语法支持。
它能为高层的编程提供更好的支持，而且通常会产生更快速的代码。

##### 示例

```c
    char ch = 7;
    void* pv = &ch;
    int* pi = pv;   // 非 C++
    *pi = 999;      // 覆盖了 &ch 附近的 sizeof(int) 个字节
```

针对在 C 中从 `void*` 或向它进行的隐式强制转换的相关规则比较麻烦而且并未强制实施。
特别是，这个例子违反了禁止把类型转换为具有更严格对齐的类型的规则。

##### 强制实施

使用 C++ 编译器。

### <a name="Rcpl-subset"></a>CPL.2: 当一定要用 C 时，应使用 C 和 C++ 的公共子集，并将 C 代码以 C++ 来编译

##### 理由

它们的子集语言，C 和 C++ 编译器都可以编译，而当作为 C++ 编译时，比“纯 C” 进行更好的类型检查。

##### 示例

    int* p1 = malloc(10 * sizeof(int));                      // 非 C++
    int* p2 = static_cast<int*>(malloc(10 * sizeof(int)));   // 非 C, C 风格的 C++
    int* p3 = new int[10];                                   // 非 C
    int* p4 = (int*) malloc(10 * sizeof(int));               // C 和 C++ 均可

##### 强制实施

- 当使用某种将代码作为 C 来编译的构建模式时进行标记。

  - C++ 将会确保代码是合法的 C++ 代码，除非使用了 C 扩展的编译器选项。

### <a name="Rcpl-interface"></a>CPL.3: 当一定要用 C 来作为接口时，应在使用这些接口的代码中使用 C++

##### 理由

C++ 比 C 的表达能力更强，而且为许多种类的编程都提供了更好的支持。

##### 示例

例如，为使用第三方 C 程序库或者 C 系统接口，可以使用 C 和 C++ 的公共子集来定义其底层接口，以获得更好的类型检查。
尽可能将底层接口封装到一个遵循了 C++ 指导方针的接口之中（以获得更好的抽象、内存安全性和资源安全性），并在 C++ 代码中使用这个 C++ 接口。

##### 示例

在 C++ 中可以调用 C：

```c
    // C 中:
    double sqrt(double);

    // C++ 中:
    extern "C" double sqrt(double);

    sqrt(2);
```

##### 示例

在 C 中可以调用 C++：

```c
    // C 中:
    X call_f(struct Y*, int);

    // C++ 中:
    extern "C" X call_f(Y* p, int i)
    {
        return p->f(i);   // 可能是虚函数调用
    }
```

##### 强制实施

不需要做什么。
