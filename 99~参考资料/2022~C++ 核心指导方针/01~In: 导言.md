# <a name="S-introduction"></a>In: 导言

本文档是一组核心指导方针，针对现代 C++（目前为 C++20 和 C++17），还考虑到了语言将来有希望的增强，以及 ISO 技术规范（TS）。
其目标是帮助 C++ 程序员编写更简单、更高效、更加可维护的代码。

导言概览：

- [In: 导言](#in-导言)
  - [In.target: 目标读者](#intarget-目标读者)
  - [In.aims: 目标](#inaims-目标)
    - [In.0: 不要慌张！](#in0-不要慌张)
  - [In.not: 非目标](#innot-非目标)
  - [In.force: 强制实施](#inforce-强制实施)
  - [In.struct: 本文档的结构](#instruct-本文档的结构)
  - [In.sec: 主章节](#insec-主章节)

## <a name="SS-readers"></a>In.target: 目标读者

所有 C++ 程序员。其中也包括[考虑采用 C 语言的程序员](#S-cpl)。

## <a name="SS-aims"></a>In.aims: 目标

本文档的目标是帮助开发者采用现代 C++（目前是 C++17），并在各个代码库之间达成更加统一的编码风格。

我们并不妄想这些规则中的每一条都能有效地在任何代码库中进行实施。对老旧系统进行升级是很困难的。不过我们确实认为，采纳了一条规则的程序总会比不这样做的程序更加不易出错也更加便于维护。通常，采用规则也会带来更快速或更容易的初始开发活动。

就我们所能说的，这些规则能够使得代码的性能，相对于更传统的技术来说同样好甚至更好；它们都是依照零开销原则设立的——“不使用就没有负担”（"what you don't use, you don't pay for"）或“当恰当地使用抽象机制时，所得的性能至少与使用低级语言构造手工编码的结果一样好”。

我们认为这些规则对新代码来说是理想的，也有很多机会在老代码中实施，并试图尽可能接近并灵活地对这些理想情况进行近似。

请记住：

### <a name="R0"></a>In.0: 不要慌张！

请花些时间理解一下指南规则对你的程序能够造成的影响。

这些指导方针都是遵循“超集的子集”原则（[Stroustrup05](#Stroustrup05)）而设计的。
它们并非仅仅定义了 C++ 的一个可以使用的子集（以获得比如说可靠性，安全性，性能，或者别的什么）。
它们强烈地推崇使用一些简单的“扩展”（[程序库组件](#gsl-guidelines-support-library)），
使得最易出错的 C++ 特性变得不再必须，并且可以（通过这些规则）禁止再使用它们。

这些规则都强调静态类型安全性和资源安全性。
鉴于此，它们强调了进行范围检查，避免对 `nullptr` 解引用，避免悬挂指针，以及（通过 RAII）系统性地使用异常的可能性。
部分地为达成这点，也部分地为了最小化会带来错误的晦涩难懂的代码，这些规则同样强调了简单性，以及将必须的复杂性隐藏于经过充分说明的接口后面。

有许多规则都是约定性质的。
我们认为，那些单纯说“禁止这样！”而又不提供替代方案的规则是不可取的。
但这样的后果就是让一些规则只能以启发式方法，而不是精确地和机械化地进行验证检查。
还有一些规则所表达的是一些一般性的原则。对于这些一般性规则，我们会提供一些更精细和更特定的规则来进行不完全的检查。

这些指导方针所关注的是 C++ 的核心部分及其使用方式。
我们认为大多数的大型团体，特定的应用领域，甚至一些大型项目都会需要更多的规则，也许是更多的限制规则，或是更多的库支持。
例如说，硬实时开发人员通常都无法随意使用自由存储（动态内存），并且在选择程序库上也有许多限制。
我们鼓励各方开发这样的专门规则，以作为我们的核心指导方针的补充。
请构建你自己的基础程序库并使用它，而不要把你的开发层次降低到汇编代码之中。

这些规则的设计使其能够进行[渐进式的采纳](#S-modernizing)。

一些规则的目标是提升各种形式的安全性，而另外一些的目标是减少意外的发生，还有许多则同时兼顾。
目标是避免意外事故的指导方针通常会禁止完全合法的 C++ 用法。
不管怎样，每当存在两种达成效果的方式，其中一种被证实是常见的错误来源，而另外一种并非如此时，我们都会努力引导程序员采纳后者。

## <a name="SS-non"></a>In.not: 非目标

我们没打算让这些规则保持精简或正交。
特别地说，一般性规则可以很简单，但却没办法强制实施。
而且要搞清楚一条一般性规则所造成的影响通常是很困难的。
通常更专门的规则都更易于理解清楚，也更易于实施，但如果没有那些一般性规则的话，它们不过是一大堆特殊情况而已。
我们既要提供能够帮到新手的规则，也要提供能够支持专家使用的规则。
其中的一些规则是完全可以强制实行的，而另外的一些则是基于启发式方案的规则。

并不需要像读书一样从头到尾地阅读这些规则。
您可以利用链接来进行浏览。
不过，这些规则的主要预期用途是作为工具的检查目标。
就是说，由工具来查找规则的违反情况，然后工具会返回指向所违反的规则的链接。
而规则之中则提供了其理由，违反规则的潜在后果的例子，以及一些改正建议。

这些指导方针并不是用来替代 C++ 的教程材料的。
如果您需要针对某个经验水平的教程，请参见[参考资料](#S-references)。

本文档并不是一份如何把老旧 C++ 代码转化为更加现代的代码的指南。
而是旨在以一种具体化的方式来阐明对于新代码的设想。
当然，对于进行代码现代化转换，使其恢复活力或者升级的可行方式，可以参考[代码现代化章节](#S-modernizing)。
重要的是，这些规则是允许渐进式采纳的：对大型代码库进行一次性全部转化通常都是不可行的。

这些指导方针并不会对于语言技术的每个细节上都保持完整和精确。
如果需要，请参考 C++ 标准，关于语言定义上的最终文本，其中包括一般性规则的每种例外情况，也包括所有特性。

这些规则不是为了强迫你使用 C++ 的某个阉割子集来编写代码的。
它们*尤其着重*避免去定义一种像（比如）Java 一样的 C++ 子集。
它们也避免去定义一个单一的所谓“真正的 C++”的语言。
我们重视语言的表达能力和不打折扣的性能。

这些规则并不是价值观中立的。
它们旨在使代码变得相对于现有大多数 C++ 代码来说更简单，并且更加正确和安全，又不会有任何性能损失。
它们旨在约束对那些完全合法的，但却与错误、虚假的复杂性以及不良性能有关的 C++ 代码的使用。

这些规则并未精炼到人们（或机器）可以无脑实施的程度。
“强制实施”部分试图做到这点，但相对于给出一些精确但却错误的东西来说，
我们更倾向于使得一条规则或者定义略微含糊，并允许不同的解读。
有时候，只有经历时间和经验的凝炼才能带来精确性。
设计（还）并不是数学的某种形式。

这些规则并不完美。
某条规则可能有害，因其可能制止了在特定情形中有益的事物。
某条规则可能有害，因其可能无法制止在特定情形中会导致某种严重错误的事物。
某条规则可能有许多害处，因其含混，有歧义，无法实施，或者对一个问题给出了所有的解决方案。
完全满足“无害”的准则是不可能的。
相对来讲，我们的目标并没那么大野心：“对大多数数程序员有最多的好处”；
如果某条规则使你无法工作，你反对它，忽略掉它，但请不要削弱它，除非它已经变得没有意义。
同样，也请给出改进的建议。

## <a name="SS-force"></a>In.force: 强制实施

无法强制实施的规则对于大型代码库来说是难以操作的。
所有规则都强制实施，则仅对于一个小的规则集合，或者对于某些特定用户群来说是可行的。

- 但我们需要大量的规则，需要每个人都能使用的规则。
- 不同的人的要求都不一样。
- 人们不想阅读大量的规则。
- 人们也无法记住太多规则。

因此，我们需要建立规则子集以满足各种不同的需要。

- 但任意性地建立子集也会导致混乱。

我们想要的是可以帮助到许多人的指导方针，使代码更加统一，并有力地促进人们将他们的代码现代化。
我们想要促进最佳实践，而不是让人们陷入大量选项之中而增加管理压力。
理想情况是使用全部规则；这会带来极大的好处。

但这样也带来了一些困难之处。
我们试图通过使用工具来解决它们。
每条规则都包括一个**强制实施**小节，列出了进行强制实施的一些建议。
所谓强制实施，可以是通过代码评审，通过静态分析，通过编译器，或者通过运行时检查来进行的。
只要可行，我们都倾向于“机械性的”检查（人类是缓慢的，不精确的，而且很容易疲倦）和静态检查。
只有当不存在其他方案时，我们才偶尔建议进行运行时检查；我们并不想带来所谓“分布式代码爆炸”。
如果适当的话，我们会（在**强制实施**小节中）将规则标以相关的规则组的名字（所谓“剖面配置”）。
一条规则可以属于多个剖面配置，也可以不属于任何剖面配置。
首先，我们有一些对应于常规需求（期望、理想目标）的剖面配置：

- **type**: 消除类型违规（如通过强制转换（cast），联合体（union），或者变参（varargs）把 `T` 重解释为 `U`）
- **bounds**: 消除边界违规（如越过数组范围的访问）
- **lifetime**: 消除泄漏（如未能 `delete` 或者进行多次 `delete`），以及消除对无效对象的访问（如解引用 `nullptr`，或使用悬挂引用）。

这些剖面配置是为工具的使用而准备的，但对人类读者也能有所帮助。
我们不打算把**强制实施**小节中的评述限定在我们了解如何强制实施的方面；其中的一些说明仅仅是一些愿望，它们可能会对一些工具构建者们造成影响。

实现这些规则的工具应当遵循下面的语法以明确抑制一条规则：

    [[gsl::suppress(tag)]]

或可选地带有一条消息（遵循常规的 C++11 标准标注语法）：

    [[gsl::suppress(tag, justification: "message")]]

其中

- `tag` 是包含强制规则的条目的锚定名字（例如，[C.134](#Rh-public) 的锚定名字为 "Rh-public"），
  剖面配置的规则组的名字（如 "type"，"bounds"，或 "lifetime"），
  或者剖面配置中的特定规则（[type.4](#Pro-type-cstylecast) 或 [bounds.2](#Pro-bounds-arrayindex)）

- `"message"` 是字符串字面量

## <a name="SS-struct"></a>In.struct: 本文档的结构

每条规则（指导方针，建议）可以包含几个部分：

- 规则本身 —— 例如，**不要使用裸 `new`**
- 一个规则参考编号 —— 例如，**C.7**（与类相关的第七条规则）。
  因为大章节之间天然是无序的，所以我们用字母来当作规则参考“编号”的第一个部分。
  我们在编号之间保留了一些间隔，以便当添加或删减规则时尽量减少“断裂”。
- **理由**（原理） —— 程序员对于他们不理解的规则是难于遵守的
- **示例** —— 抽象地理解规则是很难的；示例有正面的和负面的
- **替代方案** —— 针对“请勿……”规则
- **例外** —— 我们更喜欢简单的一般性规则。但是许多规则都是广泛适用，但并不是普遍适用的，因此必须列出例外情况
- **强制实施** —— 关于这条规则如何“机械性”地进行检查的建议
- **参见** —— 指向相关的规则，以及（本文档中或者别处的）进一步讨论
- **注解** —— 需要说明的一些内容，无法被归类到其他部分
- **探讨** —— 指向规则主列表之外的更加全面的原理说明和实例

一些规则难于机械地进行检查，但它们都满足一条最小准则，即专家程序员可以不费太多力气就能找出许多违反情况。
我们希望“机械性”工具能够随着时间获得改进，以接近这种专家程序员所能发觉的程度。
而且，我们还认为这些规则也会随着时间获得提炼，以变得更明确和易于检查。

规则应当简明，而不是谨慎地列出每种变化和特殊情况。
这些信息应当出现在**替代方案**段落和[探讨](#S-discussion)章节中。
如果您不理解或者反对一条规则，请您访问它的**探讨**部分。
如果您觉得一份探讨有缺漏或不完整，请填写一条 [Issue](https://github.com/isocpp/CppCoreGuidelines/issues)
来解释您的关切，亦或一条相应的问题报告。

各个示例用于演示规则。

- 这些示例并非意图具有产品级的质量，或覆盖所有的教学维度。
  例如，许多的例子都是语言技巧，并使用了诸如 `f`，`base`，和 `x` 这样的名字。
- 我们尝试保证使下文中“好”的示例都遵守《核心指导方针》。
- 注释通常用于演示规则，它们可能是不必要的，或者会干扰“真正的代码”。
- 我们假设读者具有标准程序库的知识。例如我们使用普通的 `vector` 而不是 `std::vector`。

本文档不是语言手册。
它旨在能够对人有所帮助，而不是变得完整，在技术细节上完全准确，或对现存代码的指南。
可以在[参考资料](#S-references)中找到一些推荐的信息来源。

## <a name="SS-sec"></a>In.sec: 主章节

- [In: 导言](#S-introduction)
- [P: 理念](#S-philosophy)
- [I: 接口](#S-interfaces)
- [F: 函数](#S-functions)
- [C: 类和类层次](#S-class)
- [Enum: 枚举](#S-enum)
- [R: 资源管理](#S-resource)
- [ES: 表达式和语句](#S-expr)
- [Per: 性能](#S-performance)
- [CP: 并发与并行](#S-concurrency)
- [E: 错误处理](#S-errors)
- [Con: 常量和不可变性](#S-const)
- [T: 模板和泛型编程](#S-templates)
- [CPL: C 风格的编程](#S-cpl)
- [SF: 源文件](#S-source)
- [SL: 标准库](#sl-the-standard-library)

配套章节：

- [A: 架构相关的理念](#S-A)
- [NR: 伪规则和错误的看法](#S-not)
- [RF: 参考资料](#S-references)
- [Pro: 剖面配置](#S-profile)
- [GSL: 指导方针支持库](#gsl-guidelines-support-library)
- [NL: 命名和代码布局建议](#S-naming)
- [FAQ: 常见问题的解答](#S-faq)
- [附录 A: 程序库](#S-libraries)
- [附录 B: 代码的现代化转换](#S-modernizing)
- [附录 C: 相关讨论](#S-discussion)
- [附录 D: 支持工具](#S-tools)
- [词汇表](#S-glossary)
- [To-do: 未分类的规则原型](#S-unclassified)

章节之间并非是正交的。

每个章节（比如，"P" 代表“理念”），以及每个子章节（比如，"C.hier" 代表“类层次（OOP）”）都有一个用以简化搜索和引用的缩写。
主章节的缩写也出现在规则编号之中（比如，"C.11" 代表“使具体类型正规化”）。
