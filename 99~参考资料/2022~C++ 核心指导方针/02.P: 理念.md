# <a name="S-philosophy"></a>P: 理念

本章节中的规则都非常具有一般性。

理念性规则概览：

- [P.1: 在代码中直接表达你的想法](#Rp-direct)
- [P.2: 用 ISO 标准 C++ 来编码](#Rp-Cplusplus)
- [P.3: 表达你的设计意图](#Rp-what)
- [P.4: 理想情况下，程序应当是静态类型安全的](#Rp-typesafe)
- [P.5: 编译期检查优先于运行时检查](#Rp-compile-time)
- [P.6: 应当使无法在编译期进行的检查能够在运行时实施](#Rp-run-time)
- [P.7: 尽早识别运行时错误](#Rp-early)
- [P.8: 不要泄漏任何资源](#Rp-leak)
- [P.9: 不要浪费时间或空间](#Rp-waste)
- [P.10: 不可变数据优先于可变数据](#Rp-mutable)
- [P.11: 把杂乱的构造封装起来，而别让其散布到代码中](#Rp-library)
- [P.12: 适当采用支持工具](#Rp-tools)
- [P.13: 适当采用支持程序库](#Rp-lib)

通常，理念性的规则都无法机械性地进行检查。
不过，这些理念主题在各个规则中都有体现。
如果没有一个理念基础的话，那些更具体、专门和可检查的规则就是缺少理论根据的了。

### <a name="Rp-direct"></a>P.1: 在代码中直接表达你的想法

##### 理由

编译器是不会去读注释（或设计文档）的，许多程序员也（固执地）不去读它们。
而代码中所表达的东西是带有明确的语义的，并且（原则上）是可以由编译器和其他工具进行检验的。

##### 示例

    class Date {
    public:
        Month month() const;  // 好
        int month();          // 不好
        // ...
    };

`month` 的第一个声明式，显然是要返回一个 `Month`，而且不会修改 `Date` 对象的状态。
而第二个版本则需要读者进行猜测，同时带来了更多的出现难于发现 BUG 的可能性。

##### 示例，不好

这个循环是 `std::find` 的一种能力有限的形式：

    void f(vector<string>& v)
    {
        string val;
        cin >> val;
        // ...
        int index = -1;                    // 不好，而且应该使用 gsl::index
        for (int i = 0; i < v.size(); ++i) {
            if (v[i] == val) {
                index = i;
                break;
            }
        }
        // ...
    }

##### 示例，好

要清晰得多地表达其设计意图，可以这样：

    void f(vector<string>& v)
    {
        string val;
        cin >> val;
        // ...
        auto p = find(begin(v), end(v), val);  // 好多了
        // ...
    }

用恰当设计的程序库来表达设计意图（要做什么，而不只是怎么做这些事），要远比直接使用语言功能好得多。

C++ 程序员应当熟知标准库的基本知识，并在适当的时候加以利用。
任何程序员都应当熟知其所工作的项目中的基础程序库的基本知识，并适当加以利用。
使用本文档的指导方针的程序员，应当熟知[指导方针支持库](#gsl-guidelines-support-library)，并适当加以利用。

##### 示例

    change_speed(double s);   // bad: s 代表什么？
    // ...
    change_speed(2.3);

更好的方案是明确给出这个 double 的含义（新的速度还是对旧速度的增量？）以及所用单位：

    change_speed(Speed s);    // 好多了：说明了 s 的含义
    // ...
    change_speed(2.3);        // 错误：没有单位
    change_speed(23_m / 10s);  // 米每秒

确实可以用普通的（没有单位的）`double` 作为增量值，但这样是易于出错的。
如果绝对速度值和增量值都需要的话，我们应当定义一个 `Delta` 类型。

##### 强制实施

通常非常困难。

- 坚持一贯地使用 `const`（检查成员函数是否会修改对象；检查函数是否会修改以指针或引用形式传递的实参）
- 将强制转换标示出来（强制转换阉割了类型系统）
- 检测模仿标准库的代码（困难）

### <a name="Rp-Cplusplus"></a>P.2: 用 ISO 标准 C++ 来编码

##### 理由

本文档正是关于用 ISO 标准 C++ 来编码的一组指导方针。

##### 注解

有些环境下是需要使用语言扩展的，例如有关访问系统资源的语言扩展。
这些情况下，应当将对所需语言扩展的使用局部化，并把它们的使用置于非核心的编码指导方针的控制之下。如果可能的话，应当构建一些接口来封装这些语言扩展，以使其能够被关闭，并当针对不支持这些语言扩展的系统时免除它们的编译。

语言扩展通常是没有严密定义的语义的。即便语言扩展很常见，
并且在多种编译器上都有实现，它们也可能有略微不一致的行为
以及边界情形下的行为，这是*缺乏*一个严格的标准定义的
直接后果。大量使用任何这样的语言扩展，都会对代码的可移植性
造成不良影响。

##### 注解

使用合法的 C++ 并不能保证可移植性（不管其正确性）。
应当避免依赖于未定义的行为（例如，[未定义的求值顺序](#Res-order)）
并应当关注带有由实现定义的含义的构造（例如，`sizeof(int)`）。

##### 注解

有些环境下是需要对标准 C++ 语言或者程序库的功能特性的使用进行限制的，例如，飞行器控制软件标准要求避免动态内存分配。
这些情况下，应当将对它们的使用（或废弃）置于对本文档针对特定环境所定制的扩充的编码指导方针之下。

##### 强制实施

使用最新版的 C++ 编译器（目前支持 C++20 或 C++17），并打开禁用语言扩展的选项。

### <a name="Rp-what"></a>P.3: 表达你的设计意图

##### 理由

一些代码如果不（比如通过命名或者代码注释）说明其设计意图的话，是不可能搞清楚代码是否达成其预定目标的。

##### 示例

    gsl::index i = 0;
    while (i < v.size()) {
        // ... 在 v[i] 上做一些事 ...
    }

这里并未表明其意图是“单纯地”循环访问 `v` 的元素。使用一个索引的实现细节被暴露了出来（因而可能导致被误用），而且 `i` 的存在超出了循环的范围，这也许符合也许违背了设计意图。读者仅从这段代码中是无法了解清楚的。

更好的方式是：

    for (const auto& x : v) { /* 用 x 的值做一些事 */ }

现在，循环机制不明确给出，而且循环的操作针对的是 `const` 元素，以防止发生意外的修改。如果需要进行修改的话，则可以这样：

    for (auto& x : v) { /* 修改 x */ }

`for` 语句的更多细节，请参见 [ES.71](#Res-for-range)。
有时候，使用具名的算法会更好。这个示例使用 Ranges TS 中的 `for_each`，因为它直接表达了意图：

    for_each(v, [](int x) { /* 用 x 的值做一些事 */ });
    for_each(par, v, [](int x) { /* 用 x 的值做一些事 */ });

最后一种写法让人明白，我们对按照何种顺序来处理 `v` 的各个元素并不关心。

程序员应当熟悉：

- [指导方针支持库](#gsl-guidelines-support-library)
- [ISO C++ 标准库](#sl-the-standard-library)
- 当前项目所使用的任何基础程序库

##### 注解

其他形式：说明要做什么，而不只是怎么做这些事。

##### 注解

一些语言构造比另一些可以更好地表达设计意图。

##### 示例

如果要用两个 `int` 来代表二维点的坐标值，应当这样：

    draw_line(int, int, int, int);  // 含混的
    draw_line(Point, Point);        // 清晰的

##### 强制实施

查找具有更加替代方案的一般模式：

- 简单 `for` 循环 vs. 范围式 `for` 循环
- `f(T*, int)` 接口 vs. `f(span<T>)` 接口
- 循环变量出现在过大的范围中
- 裸的 `new` 和 `delete`
- 带有大量内建类型的形参的函数

在聪敏的人工处理和半自动的程序变换之间存在巨大的空间。

### <a name="Rp-typesafe"></a>P.4: 理想情况下，程序应当是静态类型安全的

##### 理由

理想情况下，程序应当完全是静态（编译期）类型安全的。
不幸的是，这是不可能的。有问题的领域：

- `union`
- 强制转换
- 数组退化
- 范围错误
- 窄化转换

##### 注解

这些领域是许多严重问题（如程序崩溃和安全性违规）的来源。
我们争取为它们给出替代技术。

##### 强制实施

如果程序各自需要或者条件允许的话，我们可以逐个对这些问题类型分别进行阻止、克制或者检测。
我们总会给出替代方案。
例如：

- `union` - 使用 `variant`（C++17 提供）
- 强制转换 - 尽可能减少其使用；使用模板有助于这点
- 数组退化 - 使用 `span`（来自 GSL）
- 范围错误 - 使用 `span`
- 窄化转换 - 尽可能减少其使用，必须使用时则使用 `narrow` 或者 `narrow_cast`（来自 GSL）

### <a name="Rp-compile-time"></a>P.5: 编译期检查优先于运行时检查

##### 理由

为了代码清晰性和性能。
对于编译期识别的错误是不需要编写错误处理的。

##### 示例

    // Int 被用作整数的别名
    int bits = 0;         // 请勿如此: 可以避免的代码
    for (Int i = 1; i; i <<= 1)
        ++bits;
    if (bits < 32)
        cerr << "Int too small\n";

这个例子并没有达成其所要达成的目的（因为溢出是未定义行为），应当被替换为简单的 `static_assert`：

    // Int 被用作整数的别名
    static_assert(sizeof(Int) >= 4);    // do: 编译时检查

或者更好的方式是直接利用类型系统，将 `int` 替换 `int32_t`。

##### 示例

    void read(int* p, int n);   // 读取至多 n 个整数到 *p 之中

    int a[100];
    read(a, 1000);    // 不好，超过末尾了

更好的做法是

    void read(span<int> r); // 读取到整数区域范围 r 之中

    int a[100];
    read(a);        // 好多了: 让编译器确定元素数量

**替代形式**: 不要把可以在编译期搞定的事推后到运行时进行。

##### 强制实施

- 查找指针参数。
- 查找运行时进行的范围违反检查。

### <a name="Rp-run-time"></a>P.6: 应当使无法在编译期进行的检查能够在运行时实施

##### 理由

把难于检测的错误遗留在程序中，总会带来程序崩溃或得到错误的运行结果。

##### 注解

理想情况下我们可以在编译期或者运行时识别所有的错误（它们并非程序员的逻辑错误）。但是要在编译期识别所有的错误是不可能的，而通常也负担不起在运行时识别剩余的全部错误的代价。不过我们编写程序，应当尽量使其在原则上是可以在充足的（分析程序，运行时检查，机器资源，时间等）资源下进行检查的。

##### 示例，不好

    // 分离编译，可能会被动态加载
    extern void f(int* p);

    void g(int n)
    {
        // 不好的：并未把元素数量传递给 f()
        f(new int[n]);
    }

此处，关键性的信息（元素数量）被完全掩盖起来，使其无法进行静态分析，而如果 `f()` 属于某个 ABI 的一部分的话，由于无法对这个指针进行“测量插装”，运行时检查也是不可行的。我们确实可以在自由存储中插入有助于检查的信息，但这需要对系统甚至是编译器做出整体改动。这就是一个能让错误检查变得非常困难的设计。

##### 示例，不好

当然可以把元素数量和指针一起进行传递：

    // 分离编译，可能会被动态加载
    extern void f2(int* p, int n);

    void g2(int n)
    {
        f2(new int[n], m);  // 不好的：可能会把错误的元素数量传递给 f()
    }

把元素数量作为一个参数进行传递，比只传递指针而依靠某种（不明确的）对已知元素个数的约定或者找出元素个数的方式，要好得多，而且是更加常见的做法。但是如上所示，一个简单的错字就可以引入一个严重的错误。`f2()` 的两个参数之间的关联是基于约定的，而并不明确。

而且，这里还隐含假定 `f2()` 应当 `delete` 其参数（要不然就是调用者又犯了另一个错误）。

##### 示例，不好

使用标准库的资源管理指针指向对象时，也不能传递其大小：

    // 分离编译，可能会被动态加载
    // NB: 这里假定调用代码是 ABI 兼容的，使用的是
    // 兼容的 C++ 编译器和同一个 stdlib 实现
    extern void f3(unique_ptr<int[]>, int n);

    void g3(int n)
    {
        f3(make_unique<int[]>(n), m);    // 不好的：把所有权和大小分开进行传递
    }

##### 示例

我们得把指针和元素数量作为一个对象整体来进行传递：

    extern void f4(vector<int>&);   // 分离编译，可能会被动态加载
    extern void f4(span<int>);      // 分离编译，可能会被动态加载
                                    // NB: 这里假定调用代码是 ABI 兼容的，使用的是
                                    // 兼容的 C++ 编译器和同一个 stdlib 实现

    void g3(int n)
    {
        vector<int> v(n);
        f4(v);                     // 传递引用，保留所有权
        f4(span<int>{v});          // 传递视图，保留所有权
    }

这个设计将元素数量作为对象的固有部分，因此不太可能有错误，动态（运行时的）检查即使不总是可承担的，也总是可行的。

##### 示例

如果把所有权和验证所需的全部信息一起传递的话会怎么样呢？

    vector<int> f5(int n)    // OK: 移动
    {
        vector<int> v(n);
        // ... 初始化 v ...
        return v;
    }

    unique_ptr<int[]> f6(int n)    // 不好的：缺失了 n
    {
        auto p = make_unique<int[]>(n);
        // ... 初始化 *p ...
        return p;
    }

    owner<int*> f7(int n)    // 不好的：缺失了 n 并且我们可能会忘记 delete
    {
        owner<int*> p = new int[n];
        // ... 初始化 *p ...
        return p;
    }

##### 示例

- ???
- 展示传递多态基类的接口是如何避开可能进行的检查的，但它们实际上直到它们需要的类型？
  还有用字符串当作“自由式”选项的做法

##### 强制实施

- 标示出 (pointer, count) 形式的接口（这将标示出大量的因为兼容性原因而无法进行修正的实例）
- ???

### <a name="Rp-early"></a>P.7: 尽早识别运行时错误

##### 理由

避免“神秘的”程序崩溃。
避免能够产生（也许无法识别的）错误结果的程序错误。

##### 示例

    void increment1(int* p, int n)    // 不好的：易于出错
    {
        for (int i = 0; i < n; ++i) ++p[i];
    }

    void use1(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment1(a, m);   // 可能是打错字，可能假定有 m <= n
                            // 不过让我们假设 m == 20
        // ...
    }

我们在 `use1` 里面犯了一个能够导致数据损坏或程序崩溃的小错误。
这个 (pointer, count) 形式的接口让 `increment1()` 没有可以使其防范越界错误的任何现实可行的方式。
如果我们可以检测到越界访问的下标的话，那么这个错误直到对 `p[10]` 进行访问之前都不会被发现。
我们可以提早进行检查来改进这个代码：

    void increment2(span<int> p)
    {
        for (int& x : p) ++x;
    }

    void use2(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment2({a, m});    // 可能是打错字，可能假定有 m<=n
        // ...
    }

现在，就可以在调用点（提早地）检查 `m <= n`，而不是更晚进行了。
如果我们只是打错了字而本想用 `n` 作为边界值的话，代码还可以进一步简化（来消除一处错误的可能性）：

    void use3(int m)
    {
        const int n = 10;
        int a[n] = {};
        // ...
        increment2(a);   // 不需要重复给出 a 的元素数量
        // ...
    }

##### 示例，不好

不要对同一个值重复进行检查。不要用字符串来传递有结构的数据：

```cpp
    Date read_date(istream& is);    // 从 istream 读取日期

    Date extract_date(const string& s);    // 从 string 中抽取日期

    void user1(const string& date)    // 操作 date
    {
        auto d = extract_date(date);
        // ...
    }

    void user2()
    {
        Date d = read_date(cin);
        // ...
        user1(d.to_string());
        // ...
    }
```

这个日期被（`Date` 的构造函数）验证了两次，并以字符串（无结构的数据）的形式来传递。

##### 示例

过量的检查可能是代价昂贵的。
有些情况下提早检查可能会很低效，因为你可能根本不需要这个值，或者可能仅需要值的一部分，而这要比进行整体的检查容易得多。同样来说，不要添加能够改变接口的渐进式行为的验证性检查（例如，不要在平均复杂度为 `O(1)` 的接口中添加一个 `O(n)` 的检查）。

    class Jet {    // 物理规则是: e * e < x * x + y * y + z * z
        float x;
        float y;
        float z;
        float e;
    public:
        Jet(float x, float y, float z, float e)
            :x(x), y(y), z(z), e(e)
        {
            // 应不应该在这里检查这些值是物理上有意义的？
        }

        float m() const
        {
            // 应不应该处理这里的退化情形？
            return sqrt(x * x + y * y + z * z - e * e);
        }

        ???
    };

喷流（Jet）的物理定律（`e * e < x * x + y * y + z * z`），由于可能存在测量误差的缘故并不是不变式。

???

##### 强制实施

- 查找指针和数组：提早且不要重复进行范围检查
- 查找类型转换：消除或标示出窄化转换
- 查找未经检查的来自输入的值。
- 查找被转换成字符串的结构化数据（带有不变式的类的对象）
- ???

### <a name="Rp-leak"></a>P.8: 不要泄漏任何资源

##### 理由

即使是缓慢的资源增长，随着时间推移，也会耗尽这些资源的可用性。
这对于长时间运行的程序来说尤其重要，而且是负责任的编程行为的基础方面。

##### 示例，不好

    void f(char* name)
    {
        FILE* input = fopen(name, "r");
        // ...
        if (something) return;   // 不好的：如果 something == true 的话，将会泄漏一个文件句柄
        // ...
        fclose(input);
    }

建议采用 [RAII](#Rr-raii)：

    void f(char* name)
    {
        ifstream input {name};
        // ...
        if (something) return;   // OK: 没有泄漏
        // ...
    }

**参见**: [资源管理相关章节](#S-resource)

##### 注解

通俗地说，泄漏就是“有东西没清理干净”。
一种更重要的分类方式是“有东西无法再被清理干净”。
例如，在堆上分配一个对象，然后又丢失了最后一个指向这份分配物的指针。
不应当将这条规则误读为，要求在程序终止时必须把长期存活的对象中的分配物进行回收。
例如，依赖于系统所保证的进程停止时进行的文件关闭和内存回收行为可以简化代码。
然而，依赖于进行隐式清理的抽象机制同样简单，而且通常更加安全。

##### 注解

强制实行[生存期安全性剖面配置](#SS-lifetime)可以消除泄漏的发生。
如果和 [RAII](#Rr-raii) 所提供的资源安全性组合到一起，也可以（通过不产生任何垃圾而）消除对“垃圾收集”的需要。
如果将之和[类型和边界剖面配置](#SS-force) 组合到一起强制实施的话，你将会得到完全的类型和资源安全性，这是通过使用工具来保证的。

##### 强制实施

- 查找指针：把它们分成非所有者（默认情形）和所有者。
  如果可行的话，把所有者替换为标准库的资源封装类（如上例所示）。
  或者，也可以把这种所有者用 [GSL](#gsl-guidelines-support-library) 中的 `owner` 进行标记。
- 查找裸露的 `new` 和 `delete`
- 查找已知的返回原始指针的资源分配函数（诸如 `fopen`，`malloc`，和 `strdup` 等）

### <a name="Rp-waste"></a>P.9: 不要浪费时间或空间

##### 理由

你用的语言是 C++。

##### 注解

为达成某个目标（例如开发速度，资源安全性，或者测试的简化等）而正当花费的时间和空间是不会被浪费的。
“力求高效的另一种好处是，这一过程将强迫你更深入地理解问题。”—— Alex Stepanov

##### 示例，不好

    struct X {
        char ch;
        int i;
        string s;
        char ch2;

        X& operator=(const X& a);
        X(const X&);
    };

    X waste(const char* p)
    {
        if (!p) throw Nullptr_error{};
        int n = strlen(p);
        auto buf = new char[n];
        if (!buf) throw Allocation_error{};
        for (int i = 0; i < n; ++i) buf[i] = p[i];
        // ... 对缓冲区进行操作 ...
        X x;
        x.ch = 'a';
        x.s = string(n);    // 在 x.s 上预留 *p 的空间
        for (gsl::index i = 0; i < x.s.size(); ++i) x.s[i] = buf[i];  // 把 buf 复制给 x.s
        delete[] buf;
        return x;
    }

    void driver()
    {
        X x = waste("Typical argument");
        // ...
    }

这个确实有些夸张，但我们在产品代码中能够见到这里所犯的每个错误，甚至更糟糕。
注意，`X` 的布局保证会浪费至少 6 个字节，而且很可能更多。
错误的复制操作的定义式废掉了移动语义，使返回操作变得更慢
（请注意这里并不会保证进行返回值优化（RVO））。
为 `buf` 使用的 `new` 和 `delete` 是多余的；如果确实想要一个局部的字符串的话，我们应当使用局部的 `string`。
还有几个其他的性能 BUG 和无理由的复杂性。

##### 示例，不好

    void lower(zstring s)
    {
        for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);
    }

这个其实是一个来自产品代码的例子。
可以看到这里有一句 `i < strlen(s)`。这个表达式在循环的每次重复中都要求值，这意味着每次循环中 `strlen` 都必须走完字符串以确定其长度。我们假定在改动字符串内容过程中`tolower` 不会影响字符串的长度，因此最好在循环外面缓存长度值，而不是在每次重复中都承担其代价。

##### 注解

单个造成浪费的范例很少是显著的，而一旦它是显著的，通常也可以被高手轻易地清除掉。
但是，代码库中放任地到处散布的浪费情况，则很容易变得显著，而高手们又不像我们期望那样总是有空的。
本条规则（以及其他配套的更加具体的规则）的目的是，将与 C++ 语言的使用有关的大多数浪费情况，在其发生之前就将之清除掉。
在这之后，我们就可以查找与算法和需求有关的浪费情况了，但这超出了我们的指导方针的范畴。

##### 强制实施

许多更加具体的规则都是针对追求简单性并清除无理由浪费的总体目标的。

- 当用户定义的非预置后缀 `operator++` 或 `operator--` 函数的返回值未被使用时进行标记。优先代之以采用前缀形式。（注：使用“用户定义的非预置”是为了减弱噪声。若实践中噪声还是很显著则需要重新审视这条强制措施。）

### <a name="Rp-mutable"></a>P.10: 不可变数据优先于可变数据

##### 理由

对常量进行推理要比变量简单得多。
不可变的事物是不可能被意外改变的。
不可变性有时候也带来更好地进行优化的机会。
在常量上不会出现数据竞争。

另见 [Con: 常量和不可变性](#S-const)

### <a name="Rp-library"></a>P.11: 把杂乱的构造封装起来，而别让其散布到代码中

##### 理由

杂乱的代码更有可能隐藏有 Bug 而且难于编写。
而好的接口使用起来更容易和安全。
杂乱的，底层的代码会混杂出更多这样的代码。

##### 示例

    int sz = 100;
    int* p = (int*) malloc(sizeof(int) * sz);
    int count = 0;
    // ...
    for (;;) {
        // ... 读取一个 int 到 x 中，如果达到文件尾就退出循环 ...
        // ... 检查 x 有效 ...
        if (count == sz)
            p = (int*) realloc(p, sizeof(int) * sz * 2);
        p[count++] = x;
        // ...
    }

这段代码是低层的，啰嗦的，而且易错的。
比如说，我们就“忘了”检查内存耗尽情况。
我们可以代之以使用 `vector`：

    vector<int> v;
    v.reserve(100);
    // ...
    for (int x; cin >> x; ) {
        // ... 检查 x is 有效 ...
        v.push_back(x);
    }

##### 注解

标准库和 GSL 都是这种理念的例子。
例如，我们并不使用混乱的数组，联合体，强制转换，麻烦的生存期问题，`gsl::owner`，等等，
它们用于实现一些关键抽象，诸如 `vector`，`span`，`lock_guard`，以及 `future`，我们使用的是
一般来说比我们有更多时间和专业能力的人所设计和实现的程序库。
类似地，我们也能够而且应该设计并实现更专门的程序库，而不是将其留给用户（通常是我们自己）
来面对需要重复把低级代码搞正确的挑战。
这是作为指导方针基石的[超集的子集原则](#R0)的一种变体。

##### 强制实施

- 查找如复杂指针操作和在抽象的实现外面进行强制转换这样的“混乱代码”。

### <a name="Rp-tools"></a>P.12: 适当采用支持工具

##### 理由

许多事情机器都比人做得更好。
对于重复劳动，计算机既不会累也不会厌烦。
相对于重复性的例行任务，我们通常可以做一些更有意义的事情。

##### 示例

运行静态分析工具来验证你的代码是否遵循了你想要遵循的指导方针。

##### 注解

参见

- [静态分析工具](???)
- [并发工具](#Rconc-tools)
- [测试工具](???)

还有许多其他种类的工具，诸如源代码仓库和构建工具等等，
但这些超出了本指导方针的范围。

##### 注解

当心不要变得对过于详细定制的或者过于专门的工具链产生依赖。
它们会使得你本来可移植的代码变得不可移植。

### <a name="Rp-lib"></a>P.13: 适当采用支持程序库

##### 理由

使用设计良好，文档全面，并且有良好支持的程序库可以节省时间和工作量；
如果你的大部分工时都必须耗费在实现上的话，
程序库的质量和文档很可能要比你能做到的要好得多。
程序库的成本（时间，工作量和资金等等）可以由大量的用户所分担。
一个被广泛应用的程序库，远比一个独立的应用程序更加能够保持为最新状态，并被移植到新的系统之上。
对于被广泛应用的程序库的相关知识，也可以节省其他或未来的项目中的时间。
因此，如果你的应用领域中存在合适的程序库的话，请使用它。

##### 示例

    std::sort(begin(v), end(v), std::greater<>());

如果你不是排序算法方面的专家而且有大量时间的话，
这样的代码比你为特定的应用所编写的任何代码都更可能正确并且运行得更快。
不使用标准库（或者你的应用所采用的基础程序库）是需要明确理由的，而不是反过来。

##### 注解

默认应当优先使用

- [ISO C++ 标准库](#sl-the-standard-library)
- [指导方针支持库](#gsl-guidelines-support-library)

##### 注解

如果某个重要的领域中不存在设计良好，文档全面，并且有良好支持的程序库的话，
可能应当由你来设计并实现它，再进行使用了。
